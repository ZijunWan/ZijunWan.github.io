<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Frank Wan&#39;s Blog</title>
  
  <subtitle>世界上只有一种真正的英雄主义，就是认清生活的真相后并依然热爱它</subtitle>
  <link href="http://zijunwan.github.io/atom.xml" rel="self"/>
  
  <link href="http://zijunwan.github.io/"/>
  <updated>2024-12-15T11:41:17.231Z</updated>
  <id>http://zijunwan.github.io/</id>
  
  <author>
    <name>Zijun Wan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初学OpenGL</title>
    <link href="http://zijunwan.github.io/2024/12/15/Software/Learn-OpenGL-1/"/>
    <id>http://zijunwan.github.io/2024/12/15/Software/Learn-OpenGL-1/</id>
    <published>2024-12-15T10:39:19.000Z</published>
    <updated>2024-12-15T11:41:17.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​ 今天在公司开始了第一天的实习。首先就让学习ray casting算法。</p><p>关于ray casting算法的心得我会在学习透彻之后再写一篇文章分析。今天首先做的事情就是配置了OpenGL然后学习了OpenGL配合VS的一些基本使用。</p><p>先上代码吧</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// openGL_test_d.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stdafx.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"GL/glut.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"math.h"</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">GL_display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span>  GLfloat pi = <span class="hljs-number">3.1415926f</span>;<br>    GLfloat a = <span class="hljs-built_in">cos</span>(<span class="hljs-number">54</span> * pi / <span class="hljs-number">180</span>);<br>    GLfloat b = <span class="hljs-built_in">sin</span>(<span class="hljs-number">54</span> * pi / <span class="hljs-number">180</span>);<br>    GLfloat c = <span class="hljs-built_in">cos</span>(<span class="hljs-number">18</span> * pi / <span class="hljs-number">180</span>);<br>    GLfloat d = <span class="hljs-built_in">sin</span>(<span class="hljs-number">18</span> * pi / <span class="hljs-number">180</span>);<br>    GLfloat pointA[<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>};<br>    GLfloat pointB[<span class="hljs-number">2</span>] = { -a, -b };<br>    GLfloat pointC[<span class="hljs-number">2</span>] = { c, d };<br>    GLfloat pointD[<span class="hljs-number">2</span>] = { -c, d };<br>    GLfloat pointE[<span class="hljs-number">2</span>] = { a, -b };<br>    <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);     <span class="hljs-comment">//用于清除当前的颜色缓冲</span><br><span class="hljs-built_in">glBegin</span>(GL_LINE_LOOP);   <span class="hljs-comment">//设置连线方式位闭曲线</span><br><span class="hljs-built_in">glVertex2fv</span>(pointA);<br><span class="hljs-built_in">glVertex2fv</span>(pointB);<br><span class="hljs-built_in">glVertex2fv</span>(pointC);<br><span class="hljs-built_in">glVertex2fv</span>(pointD);<br><span class="hljs-built_in">glVertex2fv</span>(pointE);<br><span class="hljs-built_in">glEnd</span>();<br><span class="hljs-built_in">glFlush</span>();           <span class="hljs-comment">//强制刷新缓冲区，让画图程序进行</span><br>}<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-built_in">glutInit</span>(&amp;argc, argv);    <span class="hljs-comment">//初始化</span><br><span class="hljs-built_in">glutInitDisplayMode</span>(GLUT_RGB | GLUT_SINGLE);   <span class="hljs-comment">//设置显示方式RGB单缓冲</span><br><span class="hljs-built_in">glutInitWindowPosition</span>(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);             <span class="hljs-comment">//设置窗口位置</span><br><span class="hljs-built_in">glutInitWindowSize</span>(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);                 <span class="hljs-comment">//设置窗口大小</span><br><span class="hljs-built_in">glutCreateWindow</span>(<span class="hljs-string">"这真的是我的第一个openGL程序啦！！！"</span>);   <span class="hljs-comment">//窗口名称</span><br><span class="hljs-built_in">glutDisplayFunc</span>(&amp;GL_display);               <span class="hljs-comment">//函数显示</span><br><span class="hljs-built_in">glutMainLoop</span>();                            <span class="hljs-comment">//用循环让画图程序一直进行</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br> <br></code></pre></td></tr></tbody></table></figure><p>关于OpenGL的配置网上有详细教程，就不再说明了。这段代码的功能就是画一个五角星，用函数GL_display画出，这里用GLfloat而不用float的原因是不同的编译器可能float的内存大小会是32位或64位，而GLfloat不会出现这样的问题。</p><p>画图时首先定义了一些点，然后glVertex2fv用来定义这些点，并按照顺序连接起来。</p><p>总的来说，用openGL进行基础的画图工作的步骤就是这样，画图函数中先清除缓冲，然后定义点的顺序。在主函数中先进行初始化，并设置好一系列的参数，如显示方式，窗口大小，窗口位置等等，然后调用函数进行图像的显示，最后用循环让图像显示程序一直进行下去。</p><p>下面是另一个基础的图像显示代码，显示了一个六角星，图像初始化过程与画图过程与以上大致相同</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// GL_test_e.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stdafx.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;GL/glut.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"math.h"</span></span><br> <br><span class="hljs-type">const</span> GLfloat pi = <span class="hljs-number">3.1415926f</span>;<br><span class="hljs-type">const</span> GLfloat a = <span class="hljs-built_in">cos</span>(pi / <span class="hljs-number">6</span>);<br><span class="hljs-type">const</span> GLfloat b = <span class="hljs-built_in">sin</span>(pi / <span class="hljs-number">6</span>);<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GL_display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>GLfloat pointA[<span class="hljs-number">2</span>] = { <span class="hljs-number">0</span>, <span class="hljs-number">1.0</span> };<br>GLfloat pointB[<span class="hljs-number">2</span>] = { a, b };<br>GLfloat pointC[<span class="hljs-number">2</span>] = { a, -b };<br>GLfloat pointD[<span class="hljs-number">2</span>] = { <span class="hljs-number">0</span>, <span class="hljs-number">-1.0</span> };<br>GLfloat pointE[<span class="hljs-number">2</span>] = { -a, -b };<br>GLfloat pointF[<span class="hljs-number">2</span>] = { -a, b };<br><span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br><span class="hljs-built_in">glBegin</span>(GL_LINE_LOOP);<br><span class="hljs-built_in">glVertex2fv</span>(pointA);<br><span class="hljs-built_in">glVertex2fv</span>(pointE);<br><span class="hljs-built_in">glVertex2fv</span>(pointC);<br><span class="hljs-built_in">glEnd</span>();<br><span class="hljs-built_in">glFlush</span>();<br><span class="hljs-built_in">glBegin</span>(GL_LINE_LOOP);<br><span class="hljs-built_in">glVertex2fv</span>(pointF);<br><span class="hljs-built_in">glVertex2fv</span>(pointD);<br><span class="hljs-built_in">glVertex2fv</span>(pointB);<br><span class="hljs-built_in">glEnd</span>();<br><span class="hljs-built_in">glFlush</span>();<br>}<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-built_in">glutInit</span>(&amp;argc, argv);<br><span class="hljs-built_in">glutInitDisplayMode</span>(GLUT_RGB | GLUT_SINGLE);<br><span class="hljs-built_in">glutInitWindowPosition</span>(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);<br><span class="hljs-built_in">glutInitWindowSize</span>(<span class="hljs-number">600</span>, <span class="hljs-number">600</span>);<br><span class="hljs-built_in">glutCreateWindow</span>(<span class="hljs-string">"六角星"</span>);<br><span class="hljs-built_in">glutDisplayFunc</span>(&amp;GL_display);<br><span class="hljs-built_in">glutMainLoop</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="DEVELOPMENT" scheme="http://zijunwan.github.io/categories/DEVELOPMENT/"/>
    
    
    <category term="OpenGL" scheme="http://zijunwan.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>win10需要system权限才能修改的解决办法</title>
    <link href="http://zijunwan.github.io/2024/12/15/Software/Sloving-change-permission-win10/"/>
    <id>http://zijunwan.github.io/2024/12/15/Software/Sloving-change-permission-win10/</id>
    <published>2024-12-15T10:23:37.000Z</published>
    <updated>2024-12-15T11:38:20.806Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本文内容简介">本文内容简介</h1><p>今天重装了系统，一时没想清楚直接用360粉碎了windows.old文件夹。导致C盘中出现了一个以数字命名的文件夹。当我尝试去删除的时候，发现文件夹需要各种权限才能删除，有管理员权限，有system权限，还有trustedinstaller权限。这里统一给出解决方案。另外，重装系统后windows.old文件夹的删除方式应该是磁盘清理，而不是用其他的方式。</p><ol type="1"><li>首先打开文件夹属性，然后选择安全，然后选择编辑，给自己的账号对文件夹的完全控制权，这样就能删除文件夹中的内容了，但是文件夹中的子文件夹是不能删除的，所以还需要选择高级，然后更改所有者，在跳出来的弹窗中选择高级，然后选择立即查找，找到自己的账号，然后选中，让所有者是自己的账号。然后选择左下角的启用继承，并勾选下面的使用可从此对象继承的权限项目替换所有子对象的权限项目。这样只要给最上层的文件夹设置完全控制，就可以删除整个文件夹中的内容了。</li></ol><figure><img src="/img/Sloving-change-permission-win10/1.png" alt=""><figcaption>1</figcaption></figure><figure><img src="/img/Sloving-change-permission-win10/2.png" alt=""><figcaption>2</figcaption></figure><p>若是列表中没有自己的账号，可以添加一个，方法和修改所有者是一样的</p><figure><img src="/img/Sloving-change-permission-win10/3.png" alt=""><figcaption>3</figcaption></figure><figure><img src="/img/Sloving-change-permission-win10/4.png" alt=""><figcaption>4</figcaption></figure><figure><img src="/img/Sloving-change-permission-win10/5.png" alt=""><figcaption>5</figcaption></figure><figure><img src="/img/Sloving-change-permission-win10/6.png" alt=""><figcaption>6</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SOFTWARE" scheme="http://zijunwan.github.io/categories/SOFTWARE/"/>
    
    
    <category term="system" scheme="http://zijunwan.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>FPGA和CY7C68013A的连接以及控制程序</title>
    <link href="http://zijunwan.github.io/2024/12/15/Embedded/FPGA-CY7C68013/"/>
    <id>http://zijunwan.github.io/2024/12/15/Embedded/FPGA-CY7C68013/</id>
    <published>2024-12-15T10:11:38.000Z</published>
    <updated>2024-12-15T10:21:30.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本文内容简介">本文内容简介</h1><p>毕业设计的题目是“基于USB2.0的FPGA和PC之间的通讯”。用的是Altera的FPGA，具体型号暂时不清楚，后续会更新。USB控制器用的是CY7C68013A。开发软件是Quartus II 9.0。连接上是将FPGA和CY7C68013A连接，然后CY7C68013A和PC端连接。我会开一个文件夹写关于这个题目的相关文章。这是第一篇。 总的来说，搭建这个系统，主要分成两个部分。本文主要是关于FPGA控制CY7C68013A程序中的写数据部分。</p><p><strong>1. FPGA控制CY7C68013A部分的代码（Verilog/Quartus II 9.0）</strong> <strong>2. USB固件程序开发（C/Keil 5.1）</strong></p><h1 id="cy7c68013a内部结构介绍">CY7C68013A内部结构介绍</h1><p>首先介绍USB控制器，这是整个系统中很重要的一个部分。CY7C68013A是CYPress公司的一款USB控制器，使用广泛，内部结构图如下：</p><figure><img src="/img/FPGA-CY7C68013/1.png" alt=""><figcaption>CY7C68013A结构图</figcaption></figure><p>CY7C68013A有三种工作模式，Ports模式，GPIF模式，Slave FIFO模式，介绍固件程序篇再详细介绍。本次搭建的系统使用的是Slave FIFO模式。</p><h1 id="fpga和cy7c68013a的连接">FPGA和CY7C68013A的连接</h1><p>连接部分如图所示： <img src="/img/FPGA-CY7C68013/2.png" alt="硬件连接部分"></p><p>IFCLK是时钟信号。FLAGA，FLAGB，FLAGC，FLAGD都是FIFO的输出状态（空还是满或者是半满）标志信号，本次设计中暂时设定只是用一个FIFO，代码中也没有指出用的是哪个FIFO和FLAG信号，属于简化了设计 - SLOE是仅输入输出使能 - SLRD是读数据使能 - SLWR是写数据使能</p><p>FIFOADR[1:0]是FIFO选择信号，本设计中只用一个FIFO，所以代码中没有这个参数的设置 PKTEND是将FIFO的数据打包并传输到端点的输入端，就是数据输入了一部分后用这个信号将数据打包然后一起传输 FD[15:0]是数据传输信号，本次设计中使用的数据总线只有8位，简化了设计</p><h1 id="异步写信号">异步写信号</h1><p>异步写状态机示意图如下： <img src="/img/FPGA-CY7C68013/3.png" alt="异步写状态机"></p><ul><li>IDLE：当写数据事件发生时，进入状态1</li><li>状态1：激活FIFOADR[1:0]，指向输入FIFO，然后进入状态2</li><li>状态2：如果FIFO状态是满，就在状态2等待，如果没有满，就进入状态3</li><li>状态3：驱动数据到数据总线，使能SLWR信号，持续一个时钟周期后进入状态4</li><li>状态4：如果还有数据需要传输，回到状态2循环，否则结束进入IDLE状态</li></ul><p>本次设计中不考虑FIFOADR[1:0]的激活，所以在写数据事件发生时，直接进入状态2，这样可以简化设计，便于早期写代码 # Verilog代码</p><p>FPGA控制代码用Verilog编写，编译软件是Quartus II 9.0，仿真软件为Quartus自带 代码如下所示：</p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// a test for USB FIFO write</span><br><span class="hljs-comment">//last edit:2017.02.27</span><br><span class="hljs-comment">//  signal explaination</span><br><span class="hljs-comment">//  CLK(posedge) :   the Clock Signal </span><br><span class="hljs-comment">//  RRESET(posedge): restart all signal and give them a number </span><br><span class="hljs-comment">//  FULL(high means not full): to judge whether the FIFO is FULL or not  </span><br><span class="hljs-comment">//  SLOE(high),SLRD(high),SLCS(low):  control signal</span><br><span class="hljs-comment">//  SLWR: the write permitted signal</span><br><span class="hljs-comment">//  SLWR_reg(high means not permitted): the reg type of SLWR</span><br><span class="hljs-comment">//  PKTEND(low means effective): pack data</span><br><span class="hljs-keyword">module</span> JellyBeam(CLK,SLWR,SLCS,DATA,PKTEND,FULL,SLOE,RESET,SLRD);<br><span class="hljs-keyword">input</span> CLK,RESET;<br><span class="hljs-keyword">input</span> FULL;<br><span class="hljs-keyword">output</span> SLCS,SLOE,SLRD,SLWR,PKTEND;<br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]DATA;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]DATA;<br><span class="hljs-keyword">reg</span> SLCS,SLOE,SLRD,SLWR,PKTEND;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">11</span>:<span class="hljs-number">0</span>]cnt;<br><span class="hljs-keyword">reg</span> SLWR_reg;<br><br><span class="hljs-comment">//creat cnt and PKTEND</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> RESET)<br><span class="hljs-keyword">begin</span> <br>  <span class="hljs-keyword">if</span> (RESET)<br>    <span class="hljs-keyword">begin</span> <br>      cnt&lt;=<span class="hljs-number">12'b0</span>;<br>      PKTEND&lt;=<span class="hljs-number">1'b1</span>;    <span class="hljs-comment">//it's effective when it's low</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span>(SLWR_reg==<span class="hljs-number">1'b0</span> &amp;&amp;FULL==<span class="hljs-number">1'b1</span> &amp;&amp; PKTEND==<span class="hljs-number">1'b1</span>)<br>        <span class="hljs-keyword">begin</span> <br>          cnt&lt;=cnt+<span class="hljs-number">1'b1</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">case</span>({cnt[<span class="hljs-number">11</span>],cnt[<span class="hljs-number">10</span>],cnt[<span class="hljs-number">9</span>]})              <br>    <span class="hljs-comment">//the high 3-bit are 3 types of size of data pack,applying to 3 types of PKTEND </span><br>      <span class="hljs-number">3'b010</span>: <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]==<span class="hljs-number">8'b00001000</span>)       <br>                <span class="hljs-keyword">begin</span>                          <br>                  PKTEND&lt;=<span class="hljs-number">1'b0</span>;<br>                  cnt[<span class="hljs-number">11</span>:<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">011000000000</span>;<br>                <span class="hljs-keyword">end</span><br>              <span class="hljs-keyword">else</span><br>                PKTEND&lt;=<span class="hljs-number">1'b1</span>;<br>      <span class="hljs-number">3'b100</span>: <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]==<span class="hljs-number">8'b00010000</span>)<br>                <span class="hljs-keyword">begin</span><br>                  PKTEND&lt;=<span class="hljs-number">1'b0</span>;<br>                  cnt[<span class="hljs-number">11</span>:<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">101000000000</span>;<br>                <span class="hljs-keyword">end</span><br>              <span class="hljs-keyword">else</span> <br>                PKTEND&lt;=<span class="hljs-number">1'b1</span>;<br>      <span class="hljs-number">3'b110</span>: <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]==<span class="hljs-number">8'b00011000</span>)<br>                <span class="hljs-keyword">begin</span> <br>                  PKTEND&lt;=<span class="hljs-number">1'b0</span>;<br>                  cnt[<span class="hljs-number">11</span>:<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">111000000000</span>;<br>                <span class="hljs-keyword">end</span><br>              <span class="hljs-keyword">else</span><br>                PKTEND&lt;=<span class="hljs-number">1'b1</span>;<br>    <span class="hljs-keyword">default</span>: PKTEND&lt;=<span class="hljs-number">1'b1</span>;<br>    <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">//maintain the control point</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> RESET)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(RESET)<br>    <span class="hljs-keyword">begin</span> <br>      SLWR_reg&lt;=<span class="hljs-number">1'b0</span>;      <span class="hljs-comment">//slwr should be effective when it's low</span><br>      SLOE&lt;=<span class="hljs-number">1'b1</span>;<br>      SLCS&lt;=<span class="hljs-number">1'b0</span>;          <span class="hljs-comment">// beginning of the process,better to be low at the beginning</span><br>      SLRD&lt;=<span class="hljs-number">1'b1</span>;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">begin</span> <br>      SLOE&lt;=<span class="hljs-number">1'b1</span>;<br>      SLCS&lt;=<span class="hljs-number">1'b0</span>;<br>      SLRD&lt;=<span class="hljs-number">1'b1</span>;<br>        <span class="hljs-keyword">if</span>(FULL)<br>          <span class="hljs-keyword">begin</span><br>            SLWR_reg&lt;=~SLWR_reg;<br>          <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span><br>          <span class="hljs-keyword">begin</span><br>            SLWR_reg&lt;=<span class="hljs-number">1'b1</span>;<br>          <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">//write data</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> RESET)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(RESET)<br>    <span class="hljs-keyword">begin</span><br>      DATA&lt;=<span class="hljs-number">8'b00000000</span>;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">begin</span> <br>      <span class="hljs-keyword">if</span>(SLWR_reg==<span class="hljs-number">1'b0</span> &amp;&amp; FULL==<span class="hljs-number">1'b1</span> &amp;&amp; PKTEND==<span class="hljs-number">1'b1</span>)<br>        <span class="hljs-keyword">begin</span> <br>          DATA&lt;=cnt[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">//creat SLWR </span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> RESET)<br><span class="hljs-keyword">begin</span> <br>  <span class="hljs-keyword">if</span>(RESET)<br>    <span class="hljs-keyword">begin</span> <br>      SLWR&lt;=<span class="hljs-number">1'b1</span>;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">begin</span><br>      SLWR&lt;=SLWR_reg;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></tbody></table></figure><p>代码中各信号已经有了注释，在这里不再花大篇幅解释。最后仿真结果如下图：</p><figure><img src="/img/FPGA-CY7C68013/4.png" alt=""><figcaption>仿真结果</figcaption></figure><p>数据中给出的时钟频率为200MHz，FULL信号为随机给入，RESET信号在刚开始给出，后续全程为低电平，从图中可以看出，数据能正确地传输到DATA端口中，然后通过DATA端口输入到CY7C68013A中 # 总结</p><p>本文中只写了写入数据部分，而且只是一个初稿，里面很多地方进行了简化设计，后续会进行更新和改进</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="DEVELOPMENT" scheme="http://zijunwan.github.io/categories/DEVELOPMENT/"/>
    
    
    <category term="FPGA" scheme="http://zijunwan.github.io/tags/FPGA/"/>
    
    <category term="嵌入式" scheme="http://zijunwan.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Quartus ii 9.0软件的使用和win10不兼容解决方案</title>
    <link href="http://zijunwan.github.io/2024/12/15/Embedded/QuartusII/"/>
    <id>http://zijunwan.github.io/2024/12/15/Embedded/QuartusII/</id>
    <published>2024-12-15T09:55:02.000Z</published>
    <updated>2024-12-15T10:15:12.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本文内容简介">本文内容简介</h1><p>本文介绍关于quartus软件的编译和仿真的内容，以Verilog代码为例，不进行电路图绘制。也提供一种win10下仿真不兼容的解决方案</p><h1 id="quartus-ii-9.0使用教程">Quartus ii 9.0使用教程</h1><ul><li><p>首先打开quartus <img src="/img/QuartusII/1.png" alt="quartus软件首页"></p></li><li><p>新建工程文件：File-&gt;New Project Wizard <img src="/img/QuartusII/2.png" alt="新建工程文件"></p></li><li><p>出现弹窗，点击下一步会进入工程文件夹路径选择界面，根据自己需要进行设置 <img src="/img/QuartusII/3.png" alt="设置工程文件路径"></p></li><li><p>弹窗会提示是否添加设计文件，如果有需要可以添加，没有的话就直接下一步 <img src="/img/QuartusII/4.png" alt="添加设计文件"></p></li><li><p>选择自己的芯片类型 <img src="/img/QuartusII/5.png" alt="选择芯片类型"></p></li><li><p>选择设计，仿真和时序的工具，如果没有使用到额外的工具就直接下一步 <img src="/img/QuartusII/6.png" alt="选择设计工具"></p></li><li><p>核对信息是否正确 <img src="/img/QuartusII/7.png" alt="核对信息"></p></li><li><p>点击finish，选择File-&gt;New，选Verilog HDL File <img src="/img/QuartusII/8.png" alt="Verilog HDL File"></p></li><li><p>写Verilog，写完后进行编译 <img src="/img/QuartusII/9.png" alt="Verilog HDL"></p></li><li><p>点击Start Compilation，选择保存文件，然后选择Verilog HDL文件存放路径，下面的添加到现有工程文件要选上 <img src="/img/QuartusII/10.png" alt="保存文件"></p></li><li><p>编译成功后会有弹窗提示，暂时不管警告内容，可以看看flow summary <img src="/img/QuartusII/11.png" alt="编译"></p></li><li><p>新建Vector Waveform File <img src="/img/QuartusII/12.png" alt="Vector Waveform File"></p></li><li><p>在左边Name区域右键点击，选择Insert Node or Bus <img src="/img/QuartusII/13.png" alt="Name"></p></li><li><p>点击右边的Node Finder <img src="/img/QuartusII/14.png" alt="Node Finder"></p></li><li><p>点击右上角List，左边会出现需要仿真的信号，然后将Node Found中的信号选中，移动到右边的Selected Nodes <img src="/img/QuartusII/15.png" alt="Find Nodes"></p></li><li><p>点击OK，开始进行波形设置 <img src="/img/QuartusII/16.png" alt="Waveform Setting"></p></li><li><p>左边的工具栏中有各种各样的信号，时序，高电平，低电平，反转，计数，随机值等，可以自己慢慢尝试 <img src="/img/QuartusII/17.png" alt="Simulation"></p></li><li><p>点击Assignments-&gt;Settings <img src="/img/QuartusII/18.png" alt="Settings"></p></li><li><p>将Simulation mode设置为Functional <img src="/img/QuartusII/19.png" alt="Functional"></p></li><li><p>点击Processing-&gt;Generate Functional Simulation Netlist，生成功能仿真网表，会有弹窗提示保存波形文件，下面也有将文件添加至现有工程文件的选项，这个要选中 <img src="/img/QuartusII/20.png" alt="Netlist"></p></li><li><p>保存完成后会有弹窗提示，然后就可以开始仿真了 <img src="/img/QuartusII/21.png" alt="Start Simulation"></p></li></ul><h1 id="win10不兼容解决方案">win10不兼容解决方案</h1><p>这个时候如果是win10的话，会出现卡死，因为Quartus II 9.0版本较低不支持win10。解决办法就是找到Quartus的exe文件然后选择兼容win7，我的路径是D:，找到后右键-&gt;属性-&gt;兼容性-&gt;兼容win7，我还勾选了以管理员身份运行，供参考</p><figure><img src="/img/QuartusII/22.png" alt=""><figcaption>win10</figcaption></figure><p>这样选择后在仿真时还是会卡死，卡死的时候切回到桌面，可以点击右下角，也可以直接win键+D，然后再切回去，仿真就完成了 <img src="/img/QuartusII/23.png" alt="Simulation Result"></p><p>从图中可以看出，仿真结果与预期相同</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="DEVELOPMENT" scheme="http://zijunwan.github.io/categories/DEVELOPMENT/"/>
    
    
    <category term="FPGA" scheme="http://zijunwan.github.io/tags/FPGA/"/>
    
    <category term="嵌入式" scheme="http://zijunwan.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>WORLD Vocoder</title>
    <link href="http://zijunwan.github.io/2022/01/25/SignalProcessing/WORLD-Vocoder/"/>
    <id>http://zijunwan.github.io/2022/01/25/SignalProcessing/WORLD-Vocoder/</id>
    <published>2022-01-25T02:22:32.000Z</published>
    <updated>2024-12-15T11:36:08.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>WORLD是由Yamanashi大学的MORISE团队在2016年开发的一款语音合成软件[1]，可以用来合成高质量的语音信号。该软件的特点是计算量小，能实时合成语音信息，且合成声音质量高于传统的合成算法。</p><h2 id="method">Method</h2><p>WORLD的系统框架如图1所示，其合成主要包括以下几个步骤：</p><ul><li>计算基础频率F0，使用DIO算法</li><li>计算频谱的包络线， 使用CheapTrick算法</li><li>计算非周期信号参数Aperiodicity parameters，使用PLATINUM算法</li></ul><figure><img src="/img/WORLD-Vocoder/1.png" alt=""><figcaption>图1：WORLD声码器计算流程图</figcaption></figure><h3 id="f0计算">F0计算</h3><p>F0是指一段声音信号的基频，即一段周期信号变化的最小频率。人声信号的F0决定了一段声音的音调特征，即被试声带的振动频率。一般来讲，男声的F0会比女声的低。F0有多种估计方法，例如YIN[2]、SWIPE[3]等。本文使用的是DIO算法[4, 5]，相较于之前的算法，DIO的计算更快，质量也很高。</p><p>DIO的计算分为3步：首先，我们用不同截止频率的低通滤波器对信号滤波，如果滤波后只有单个频率，将其转换为正弦周期信号并计算其周期<span class="math inline">\(T_0\)</span>。这样就得到了多个周期；然后计算信号的峰峰值，过零点间距等4个值，如图2所示。对于每个周期信号，这4个值的平均值就作为其对F0的估计，然后这4个值的标准差作为F0计算可信度的量化指标。因为理论上对于F0，这4个值应该是相等的，即标准差为0；最后选择可信度最高的周期信号对应的F0作为最终的估计值。</p><figure><img src="/img/WORLD-Vocoder/2.png" alt=""><figcaption>图2：使用DIO算法计算F0</figcaption></figure><h3 id="频谱估计">频谱估计</h3><p>频谱估计中，会计算声音信号的倒频谱（Cepstrum）然后用线性预测编码（Linear Prediction Coding）进行估计。LPC的计算依赖于信号的时序特征，而频谱的估计需要尽量避免这种依赖。因此发展出了一些估计算法，例如STRAIGHT及其改进版。WORLD中使用的是CheapTrick算法[6, 7]，其主要计算如下：</p><ul><li>首先估计信号的功率谱，使用的是长度为<span class="math inline">\(3T_0\)</span>的汉宁窗</li></ul><p><span class="math display">\[\sum_{0}^{3T_0}(y(t)\omega(t))^2dt = 1.125 \sum_{0}^{T_0}y^2(t)dt\]</span></p><ul><li>然后对功率谱做平滑处理，用宽度为<span class="math inline">\(2\omega_0 / 3\)</span>的三角窗平滑，其中<span class="math inline">\(\omega_0 = 2\pi / T_0\)</span></li></ul><p><span class="math display">\[P_s(\omega) = \frac{3}{2\omega_0} \sum_{\omega_0/3}^{-\omega_0/3}P(\omega+\lambda)d\lambda\]</span></p><ul><li>最后计算倒频谱，用同态滤波来计算</li></ul><p><span class="math display">\[P_l(\omega) = exp(F(\frac{sin(\pi f_0 \tau)}{\pi f_0 \tau} * (q_0 + 2q_1 cos(\frac{2\pi \tau}{T_0})) p_s(\tau)))\]</span></p><p><span class="math display">\[p_s(\tau) = F^{-1}(log(P_s(\omega)))\]</span></p><h3 id="非周期信号参数估计">非周期信号参数估计</h3><p>WORLD用PLATINUM算法[8]来估计非周期参数（Aperiodic Parameter）。AP的计算在其他合成算法中也有使用，例如STRAIGHT、TANDEM-STRAIGHT等。PLATINUM算法计算如下：。</p><ul><li><p>首先对波形添加宽为<span class="math inline">\(2T_0\)</span>的窗，计算其频谱<span class="math inline">\(X(\omega)\)</span></p></li><li><p>然后用频谱除以最小相谱得到<span class="math inline">\(X_p(\omega)\)</span></p></li></ul><p><span class="math display">\[X_p(\omega) = \frac{X(\omega)}{S_m(\omega)}\]</span></p><ul><li>最小相谱的计算如下：</li></ul><p><span class="math display">\[S_m(\omega) = exp(F[c_m(\tau)])\]</span></p><p><span class="math display">\[c_m(\tau)=\left \{ \begin{align}  2c(\tau), \tau&gt;0\\  c(\tau), \tau=0\\  0, \tau&lt;0\end{align}\right.\]</span></p><ul><li>最后计算<span class="math inline">\(X_p(\omega)\)</span>的逆傅立叶变换，得到非周期参数<span class="math inline">\(x_p(t)\)</span></li></ul><p><span class="math display">\[x_p(t) = F^{-1}[X_p(\omega)]\]</span></p><h2 id="合成">合成</h2><p>计算得到F0，频谱和非周期信号后。通过频谱包络计算最小相位谱，然后与激励信号计算卷积，即可得到合成的语音信号，计算框架如图3所示</p><figure><img src="/img/WORLD-Vocoder/3.png" alt=""><figcaption>图3：使用WORLD合成语音的系统框架</figcaption></figure><h2 id="代码">代码</h2><p><a href="https://github.com/mmorise/World">WORLD</a>的代码是基于C++的。Github上也有其Python Wrapper库--<a href="https://github.com/JeremyCCHsu/Python-Wrapper-for-World-Vocoder">PyWorld</a>。其使用样例如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#获取音频的采样点数值以及采样率</span><br>x, fs = sf. read( <span class="hljs-string">'utterance/vaiueo2d.wav'</span>)<br><span class="hljs-comment">#使用DIO算法计算音频的基频F0</span><br>_f <span class="hljs-number">0</span>, t = pw.dio( x, fs, f0_floor= <span class="hljs-number">50.0</span>, f0_ceil= <span class="hljs-number">600.0</span>, channels_in_octave= <span class="hljs-number">2</span>, frame_period=args.frame_period, speed=args.speed)<br><span class="hljs-comment">#使用CheapTrick算法计算音频的频谱包络</span><br>_sp = pw.cheaptrick( x, _f <span class="hljs-number">0</span>, t, fs)<br><span class="hljs-comment">#计算aperiodic参数</span><br>_ap = pw.d4c( x, _f <span class="hljs-number">0</span>, t, fs)<br><span class="hljs-comment">#基于以上参数合成音频</span><br>_y = pw.synthesize(_f <span class="hljs-number">0</span>, _sp, _ap, fs, args.frame_period)<br><span class="hljs-comment">#写入音频文件</span><br>sf. write( <span class="hljs-string">'test/y_without_f0_refinement.wav'</span>, _y, fs)<br></code></pre></td></tr></tbody></table></figure><h2 id="references">References</h2><p>[1] Morise M, Yokomori F, Ozawa K. WORLD: a vocoder-based high-quality speech synthesis system for real-time applications[J]. IEICE TRANSACTIONS on Information and Systems, 2016, 99(7): 1877-1884.</p><p>[2] A. Cheveign´e and H. Kawahara, “Yin, a fundamental frequency estimator for speech and music,” J. Acoust. Soc. Am., vol.111, no.4, pp.1917–1930, 2002.</p><p>[3] A. Camacho and J.G. Harris, “A sawtooth waveform inspired pitch estimator for speech and music,” J. Acoust. Soc. Am., vol.124, no.3, pp.1638–1652, 2008.</p><p>[4] M. Morise, H. Kawahara, and H. Katayose, “Fast and reliable f0 estimation method based on the period extraction of vocal fold vibration of singing voice and speech,” in Proc. AES 35th International Conference, CD-ROM Proceedings, 2009.</p><p>[5] M. Morise, H. Kawahara, and T. Nishiura, “Rapid f0 estimation for high-snr speech based on fundamental component extraction,” IEICE Trans. Inf. &amp; Syst. (Japanese Edition), vol.J93-D, no.2, pp.109–117, 2010.</p><p>[6] M. Morise, “Cheaptrick, a spectral envelope estimator for high-quality speech synthesis,” Speech Communication, vol.67, pp.1–7, 2015.</p><p>[7] M. Morise, “Error evaluation of an f0-adaptive spectral envelope estimator in robustness against the additive noise and f0 error,” IEICE Trans. on Information Systems, vol.E98-D, no.7, pp.1405–1408, 2015.</p><p>[8] M. Morise, “Platinum: A method to extract excitation signals for voice synthesis system,” Acoust. Sci. &amp; Tech., vol.33, no.2, pp.123–125, 2012.</p><p>[9] <a href="https://www.sohu.com/a/219420730_723464">开源的语音合成系统WORLD介绍以及使用方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SIGNAL PROCESSING" scheme="http://zijunwan.github.io/categories/SIGNAL-PROCESSING/"/>
    
    
    <category term="Audio" scheme="http://zijunwan.github.io/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>Mel Frequency Cepstral Coefficients</title>
    <link href="http://zijunwan.github.io/2022/01/18/SignalProcessing/Mel-Frequency-Cepstral-Coefficients/"/>
    <id>http://zijunwan.github.io/2022/01/18/SignalProcessing/Mel-Frequency-Cepstral-Coefficients/</id>
    <published>2022-01-18T02:27:41.000Z</published>
    <updated>2024-12-15T11:34:58.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>在语音信号处理中，我们需要得到不同声音的不同特征表示。这样我们可以对声音进行区分。对于传统的信号处理，我们常用频域分布，功率谱，能量等特征来描述一个一维信号。语音信号也不例外，作为一种常用的一维信号，其处理仍旧会使用传统的方法。但是也有些许不同。于是，我们就需要用 MFCC，即梅尔倒频谱系数来计算语音信号的特征。 与传统的信号处理不同的是，语音信号的处理需要考虑到人耳听到声音的感觉和传统方式处理后的数据的对应关系。例如：人的耳蜗会根据声音的不同在不同的地方共振；也不会太区分两个很细微的频率，特别是高频的声音；而且，人类对于声音大小的感知不是线性的，所以我们会计算对数。</p><h2 id="method">Method</h2><p>MFCC的计算主要包括以下几个步骤：</p><ol type="1"><li>预加重(Pre-Emphasis)</li></ol><p><span class="math display">\[ y(t) = x(t) - \alpha x(t-1) \]</span></p><p>其中，<span class="math inline">\(y(t)\)</span>是预加重后的数据, <span class="math inline">\(x(t)\)</span>是原始信号, <span class="math inline">\(\alpha\)</span>是预加重系数，一般介于0.97-1之间。其目的主要是提升高频部分，使信号的频谱更加平坦。同时，也避免后面计算傅立叶变换时出现数值问题。比较预加重前后的音频信号，如图1所示。 <img src="/img/Mel-Frequency-Cepstral-Coefficients/1.png" alt="Fig-1: 预加重前后音频信号对比"></p><ol start="2" type="1"><li><p>分帧(Frame) 也就是分bin，需要将原始信号拼接起来形成帧。每一帧的时间长度一般是20ms-30ms左右。然后也会采取滑动窗的形式，避免帧和帧之间差距过大。目前常用处理方式是，控制帧的范围在20ms-30ms之间，每一帧的重叠部分在50%左右。分帧后的音频信号如图2所示。可以看出和预加重的信号基本一致。 <img src="/img/Mel-Frequency-Cepstral-Coefficients/2.png" alt="Fig-2: 分帧后的音频信号"></p></li><li><p>加窗 (Window) 对每一帧数据进行划窗处理，用增加数据之间的连续性。对于非周期信号，由于傅立叶变换只能计算有限长度的信号，如果不加滑动窗，会产生频域泄漏。所以，可以用窗函数对信号进行截断，来减少这种频域的泄漏问题。这里我们使用汉宁窗。 <span class="math display">\[ w(n) = (1-a) - a \times cos(\frac{2 \pi n}{N-1})\]</span> 其中，<span class="math inline">\(N\)</span>是汉宁窗的长度，<span class="math inline">\(a\)</span>是汉宁窗的系数，一般取0.46。 所以，加窗后的信号为： <span class="math display">\[s(n) = x(n) \times w(n)\]</span> 其中，<span class="math inline">\(s(n)\)</span>是加窗后的信号，<span class="math inline">\(x(n)\)</span>是原始信号。</p></li><li><p>傅立叶变换(FFT) 对信号进行FFT，计算当前信号的频谱特性。 <span class="math display">\[ X(k) = \sum_{n=0}^{N-1} x(n) \times e^{-2\pi i k / N}, 0 \leq k \leq N-1 \]</span> 其中，<span class="math inline">\(X(k)\)</span>是频谱，<span class="math inline">\(x(n)\)</span>是加窗后的语音信号，<span class="math inline">\(N\)</span>是FFT点数。上述音频信号的功率谱如图3所示: <img src="/img/Mel-Frequency-Cepstral-Coefficients/3.png" alt="Fig-3: 音频信号的功率谱"></p></li><li><p>三角带通滤波器 将计算后的频谱用三角滤波器滤波。这组三角滤波器是与Mel尺度匹配的。一般来讲滤波器的个数在40个。梅尔频谱会更加关注低频的信号，而对高频的信号用低分辨率的感知。Mel三角滤波器组如图4所示。 <img src="/img/Mel-Frequency-Cepstral-Coefficients/4.jpeg" alt="Fig-4: Mel三角滤波器组"> Mel频谱和真实频谱之间的换算关系如下: <span class="math display">\[ m = 2595 log_{10}(1+\frac{f}{700})\]</span> <span class="math display">\[ f = 700(10^{m/2595}-1)\]</span> 其中，<span class="math inline">\(m\)</span>是Mel频谱，<span class="math inline">\(f\)</span>是真实频谱。 三角滤波器组的频率响应可以如下表示： <span class="math display">\[ H_m(k) = \begin{cases} 0 &amp; {k\leq f(m-1)} \newline \frac{2(k-f(m-1))}{(f(m+1)-f(m-1))(f(m)-f(m-1))} &amp; {f(m-1) \leq k \leq f(m)} \newline \frac{2(f(m+1)-k)}{(f(m+1)-f(m-1))(f(m)-f(m-1))} &amp; {f(m) \leq k \leq f(m+1)} \newline 0 &amp; {k \geq f(m+1)} \end{cases}\]</span> 其中，<span class="math inline">\(H_m(k)\)</span>是三角滤波器组的频率响应。<span class="math inline">\(f(m)\)</span>表示第<span class="math inline">\(m\)</span>个三角滤波器的中心频率。</p></li><li><p>离散余弦变换(DCT) 将上述滤波器组的系数进行离散余弦变换： <span class="math display">\[ C(n) = \sum_{m=0}^{n-1}s(m)cos(\frac{\pi n(m-0.5)}{M}), n = 1, 2, ..., L \]</span> DCT在这里的主要作用，是去除滤波器组中系数的高度相关性，将滤波器组系数的能量聚集起来，去除那些能量小的系数。经过计算以后，得到的就是MFCC系数了。</p></li></ol><p>以上就是MFCC的计算过程。对于语音问题，我们一般在计算DCT得到MFCC后，会再用正弦函数进行处理 (sinusoidal liftering)。主要是来淡化高阶MFCC系数的影响。因为在语音识别时，更高频的信号大多数是噪声。最后，我们一般也会进行归一化处理。得到的结果如图5所示。 <img src="/img/Mel-Frequency-Cepstral-Coefficients/5.png" alt="Fig-5: Filter Bank 和 MFCC归一化后的结果"></p><h2 id="code">Code</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> soundfile <span class="hljs-keyword">as</span> sf<br><span class="hljs-keyword">from</span> scipy.fftpack <span class="hljs-keyword">import</span> dct<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># pre-emphasis</span><br>alpha = <span class="hljs-number">0.97</span><br>f = sf.SoundFile(<span class="hljs-string">'bjkjg.wav'</span>)<br>d, sr = f.read(), f.samplerate<br>pd = np.append(d[<span class="hljs-number">0</span>], d[<span class="hljs-number">1</span>:] - alpha * d[:-<span class="hljs-number">1</span>])<br><br><span class="hljs-comment"># framing</span><br>frame_size, frame_stride = <span class="hljs-number">0.025</span>, <span class="hljs-number">0.01</span><br>frame_length = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">round</span>(frame_size*sr))<br>frame_step = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">round</span>(frame_stride*sr)) <br>signal_length = <span class="hljs-built_in">len</span>(pd)<br>num_frames = <span class="hljs-built_in">int</span>(np.ceil(<span class="hljs-built_in">float</span>(np.<span class="hljs-built_in">abs</span>(signal_length-frame_length))/frame_step))<br><br>pad_signal_length = num_frames * frame_step + frame_length<br>pad_signal = np.append(pd, np.zeros((pad_signal_length - signal_length)))<br><br>indices = np.tile(np.arange(<span class="hljs-number">0</span>,frame_length),(num_frames,<span class="hljs-number">1</span>))+np.tile(np.arange(<span class="hljs-number">0</span>,num_frames*frame_step,frame_step), (frame_length, <span class="hljs-number">1</span>)).T<br>frames = pad_signal[np.mat(indices).astype(np.int32, copy=<span class="hljs-literal">False</span>)]<br><br><span class="hljs-comment"># windowing</span><br>frames *= np.hamming(frame_length)<br><br><span class="hljs-comment"># fft</span><br>NFFT = <span class="hljs-number">512</span><br>mag_frames = np.absolute(np.fft.rfft(frames, NFFT))  <span class="hljs-comment"># Magnitude of the FFT</span><br>pow_frames = (<span class="hljs-number">1.0</span> / NFFT) * (mag_frames ** <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># filter banks</span><br>nfilt=<span class="hljs-number">40</span><br>low_freq_mel = <span class="hljs-number">0</span><br>high_freq_mel = (<span class="hljs-number">2595</span> * np.log10(<span class="hljs-number">1</span> + (sr / <span class="hljs-number">2</span>) / <span class="hljs-number">700</span>))  <span class="hljs-comment"># Convert Hz to Mel</span><br>mel_points = np.linspace(low_freq_mel, high_freq_mel, nfilt + <span class="hljs-number">2</span>)  <span class="hljs-comment"># Equally spaced in Mel scale</span><br>hz_points = (<span class="hljs-number">700</span> * (<span class="hljs-number">10</span>**(mel_points / <span class="hljs-number">2595</span>) - <span class="hljs-number">1</span>))  <span class="hljs-comment"># Convert Mel to Hz</span><br><span class="hljs-built_in">bin</span> = np.floor((NFFT + <span class="hljs-number">1</span>) * hz_points / sr)<br><br>fbank = np.zeros((nfilt, <span class="hljs-built_in">int</span>(np.floor(NFFT / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>))))<br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, nfilt + <span class="hljs-number">1</span>):<br>    f_m_minus = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>[m - <span class="hljs-number">1</span>])   <span class="hljs-comment"># left</span><br>    f_m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>[m])             <span class="hljs-comment"># center</span><br>    f_m_plus = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>[m + <span class="hljs-number">1</span>])    <span class="hljs-comment"># right</span><br><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(f_m_minus, f_m):<br>        fbank[m - <span class="hljs-number">1</span>, k] = (k - <span class="hljs-built_in">bin</span>[m - <span class="hljs-number">1</span>]) / (<span class="hljs-built_in">bin</span>[m] - <span class="hljs-built_in">bin</span>[m - <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(f_m, f_m_plus):<br>        fbank[m - <span class="hljs-number">1</span>, k] = (<span class="hljs-built_in">bin</span>[m + <span class="hljs-number">1</span>] - k) / (<span class="hljs-built_in">bin</span>[m + <span class="hljs-number">1</span>] - <span class="hljs-built_in">bin</span>[m])<br>filter_banks = np.dot(pow_frames, fbank.T)<br>filter_banks = np.where(filter_banks == <span class="hljs-number">0</span>, np.finfo(<span class="hljs-built_in">float</span>).eps, filter_banks)  <span class="hljs-comment"># Numerical Stability</span><br>filter_banks = <span class="hljs-number">20</span> * np.log10(filter_banks)  <span class="hljs-comment"># dB</span><br><br><span class="hljs-comment"># dct</span><br>num_ceps = <span class="hljs-number">24</span><br>mfcc = dct(filter_banks, <span class="hljs-built_in">type</span>=<span class="hljs-number">2</span>, axis=<span class="hljs-number">1</span>, norm=<span class="hljs-string">'ortho'</span>)[:, <span class="hljs-number">1</span> : (num_ceps + <span class="hljs-number">1</span>)]<br>(nframes, ncoeff) = mfcc.shape<br><br><span class="hljs-comment"># liftering</span><br>n = np.arange(ncoeff)<br>cep_lifter =<span class="hljs-number">22</span><br>lift = <span class="hljs-number">1</span> + (cep_lifter / <span class="hljs-number">2</span>) * np.sin(np.pi * n / cep_lifter)<br>mfcc *= lift<br><br><span class="hljs-comment"># normalize</span><br>filter_banks -= (np.mean(filter_banks, axis=<span class="hljs-number">0</span>) + <span class="hljs-number">1e-8</span>)<br>mfcc -= (np.mean(mfcc, axis=<span class="hljs-number">0</span>) + <span class="hljs-number">1e-8</span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="references">References</h2><ol type="1"><li><a href="https://haythamfayek.com/2016/04/21/speech-processing-for-machine-learning.html">Speech Processing for Machine Learning: Filter banks, Mel-Frequency Cepstral Coefficients (MFCCs) and What's In-Between</a></li><li><a href="https://blog.csdn.net/jojozhangju/article/details/18678861">语音特征参数MFCC提取过程详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/24318554">语音识别第4讲：语音特征参数MFCC</a></li><li><a href="https://zhuanlan.zhihu.com/p/85299446">详解离散余弦变换（DCT）</a></li><li>Mohamed A. Deep Neural Network Acoustic Models for ASR[D]. University of Toronto, 2014.</li><li>Muda L, Begam M, Elamvazuthi I. Voice recognition algorithms using mel frequency cepstral coefficient (MFCC) and dynamic time warping (DTW) techniques[J]. arXiv preprint arXiv:1003.4083, 2010.</li><li>Zheng F, Zhang G, Song Z. Comparison of different implementations of MFCC[J]. Journal of Computer science and Technology, 2001, 16(6): 582-589.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SIGNAL PROCESSING" scheme="http://zijunwan.github.io/categories/SIGNAL-PROCESSING/"/>
    
    
    <category term="Audio" scheme="http://zijunwan.github.io/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>本地打开远程tensorboard</title>
    <link href="http://zijunwan.github.io/2022/01/13/Software/tensorboard-ssh/"/>
    <id>http://zijunwan.github.io/2022/01/13/Software/tensorboard-ssh/</id>
    <published>2022-01-13T08:30:51.000Z</published>
    <updated>2024-12-15T11:42:27.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题">问题</h3><p>在实验过程中，代码一般运行在服务器，但是连接服务器的图形界面一般比较麻烦，大部分情况下还是ssh连接。所以我们需要能在本地查看服务器上的代码运行进度。</p><h3 id="解决办法">解决办法</h3><p>如何解决这个问题呢？我们在服务器上运行tensorboard，设置好对应的端口，然后用ssh将本地的端口映射到服务器上tensorboard的端口。然后在本地浏览器打开localhost的对应端口，就能查看tensorboard的进度了。整个过程其实是一个映射的过程。</p><h3 id="代码">代码</h3><ul><li>在服务器上运行tensorboard</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tensorboard --logdir=&lt;log path&gt; --port=&lt;server port&gt; --host=&lt;server ip&gt;<br></code></pre></td></tr></tbody></table></figure><p>其中log path是tensorboard的日志路径，server port是tensorboard的端口，注意不要和本地其他端口冲突。server ip是服务器的IP地址。</p><ul><li>在本地运行ssh连接服务器</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -L &lt;local port&gt;:&lt;server ip&gt;:6006 username@&lt;server ip&gt;<br></code></pre></td></tr></tbody></table></figure><p>其中local port是本地的映射端口，server ip是服务器的ip地址，username是ssh的用户名。</p><ul><li>在本地浏览器打开本地端口 打开浏览器，输入网址：localhost:<local port="">，就能查看tensorboard的进度了。</local></li></ul><h3 id="结果">结果</h3><figure><img src="/img/tensorboard_ssh/1.jpg" alt=""><figcaption>tensorboard in local</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SOFTWARE" scheme="http://zijunwan.github.io/categories/SOFTWARE/"/>
    
    
    <category term="ssh" scheme="http://zijunwan.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>tmux常用命令</title>
    <link href="http://zijunwan.github.io/2022/01/07/Software/tmux-command/"/>
    <id>http://zijunwan.github.io/2022/01/07/Software/tmux-command/</id>
    <published>2022-01-07T02:24:53.000Z</published>
    <updated>2024-12-15T11:42:29.788Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用ssh连接服务器时，如果本地长时间没有操作，ssh会断开连接。这样会带来很多麻烦。首先是需要重新输入密码再连接，当然如果服务器有public key，这个过程可以省略。然后是ssh断开前的终端会自动关闭，这样如果是在跑代码的话，程序就中断了。为了解决这个问题，可以使用tmux，一个终端的多窗口管理工具。 tmux的作用很简单，就是新建终端，这个终端会一直保持在后台，即是ssh连接断开，终端也会继续运行。所以也就避免了上述的第二个问题。对于第一个问题，tmux在网络正常的情况下，是一直连接的。并不会出现ssh这种长时间不操作就断开的情况。tmux的主要用法如下：</p><ul><li>创建终端，这一步要在服务器上进行，在哪儿进行就是在哪台机器上新建终端，所以一般都是在服务器</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux new -s &lt;name&gt;<br></code></pre></td></tr></tbody></table></figure><p>这里的name是终端的名字，如果不设置的话，直接输入tmux就可以了，那么终端的名字默认是0，1，2以此类推。但是后期查找起来会很麻烦，如果终端很多的话。所以还是建议写个名字</p><ul><li>连接到已有的tmux终端</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux attach -t &lt;name&gt;<br></code></pre></td></tr></tbody></table></figure><p>这里的name就是上面的name。如果没设置的话，就是0，1，2这些数字编号。如果忘记了终端的名字，那么可以用</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux ls<br></code></pre></td></tr></tbody></table></figure><p>上述命令可以查询已有的tmux终端名字</p><ul><li>分离终端，如果需要关闭某一个终端，可以使用这一命令。值得注意的是，此命令只会关闭终端显示，但是仍旧会在后台运行</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux detach<br>tmux detach -P -s &lt;session name&gt;<br></code></pre></td></tr></tbody></table></figure><p>这一命令可以带参数，可以不带参数。如果不带参数，在哪个tmux终端窗口运行就detach哪个；如果带参数"s“，可以指定要detach的窗口。如果带参数"P"，那么会断开对应窗口的ssh连接，但是终端还是在后台运行。</p><ul><li>切换终端</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux switch -t &lt;name&gt;<br></code></pre></td></tr></tbody></table></figure><p>将当前终端切换到另外一个终端</p><ul><li>退出终端</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux kill-session -t &lt;name&gt;<br></code></pre></td></tr></tbody></table></figure><p>这一命令会退出当前的终端，其中运行的任务也会自动终止</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SOFTWARE" scheme="http://zijunwan.github.io/categories/SOFTWARE/"/>
    
    
    <category term="ssh" scheme="http://zijunwan.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Conditional Generative Adversarial Nets</title>
    <link href="http://zijunwan.github.io/2021/12/25/DeepLearning/Conditional-Generative-Adversarial-Nets/"/>
    <id>http://zijunwan.github.io/2021/12/25/DeepLearning/Conditional-Generative-Adversarial-Nets/</id>
    <published>2021-12-25T13:46:40.000Z</published>
    <updated>2024-12-15T11:30:52.197Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>本文主要介绍GAN的一种改进形式，Conditional GAN。原始的GAN更多的关注于数据的生成，但是由于输入的随机性，所以GAN生成数据具有很强的随机性。数据生成很”自由“。对于目前的应用来说，我们更希望是生成的数据能是受控制的，是和输入有关的。于是就有了CGAN。</p><h2 id="methods">Methods</h2><p>CGAN的基本框架如图-1所示。主要的改进就是在生成器和判别器的输入中都加入了label。生成器中加入label，可以生成对应的数据，即生成的数据分布和label相关<span class="math inline">\(G(z|y)\)</span>。判别器中加入label，可以判断数据是否和label相关。这样经过CGAN的损失函数迭代，可以使得生成的数据越来越靠近label对应的数据分布。</p><figure><img src="/img/Conditional-Generative-Adversarial-Nets/1.jpg" alt=""><figcaption>图1: CGAN基本框架</figcaption></figure><p>CGAN的损失函数如下。其中，<span class="math inline">\(x\)</span>是真实数据，<span class="math inline">\(y\)</span>是label，<span class="math inline">\(z\)</span>是用于生成数据的噪声信号。</p><p><span class="math display">\[\underset{G}{min} \underset{D}{max} V(D, G) = E_{x \sim p_{data}(x)}[log(D(x|y))]+E_{z \sim p_{z}}[log(1-D(G(z|y)))]\]</span></p><h2 id="applications">Applications</h2><p>CGAN的应用很广泛，可以用来生成特定风格的图像，或者特定的文字等内容。例如在pix2pix中[2]，我们用CGAN根据图像轮廓去进行颜色填充，根据地图轮廓去生成真实图像等。根据黑夜的图像生成白天的图像等。图2展示了根据轮廓进行颜色填充。</p><figure><img src="/img/Conditional-Generative-Adversarial-Nets/2.jpg" alt=""><figcaption>图2: pix2pix生成图像</figcaption></figure><p>参考文献[2]总结了CGAN生成图像时的一些常用的技巧，例如loss function的定义，patchGAN的应用等。文章中提到了，现有的生成模型的损失函数主要集中于计算像素点直接的平均距离，这样很容易忽视局部的信息，导致生成图像模糊。所以文章的改进如下：</p><ul><li>在CGAN的损失函数中加入L1范数，关注全局的相似度；而CGAN本身的损失函数则关注于图像的轮廓等局部信息</li></ul><p>GAN的损失函数： <span class="math display">\[L_{GAN}(G, D) = \underset{G}{min}\underset{D}{max}E_y[log(D(y))]+E_{x, z}[log(1-D(G(x, z)))]\]</span></p><p>L1范数： <span class="math display">\[L_{L1}(G) = E_{(x,y,z)} ||(y - G(x, z))||^1 \]</span></p><p>损失函数： <span class="math display">\[G^* = L_{GAN}(G, D) + \lambda * L_{L1}(G)\]</span></p><ul><li>加入dropout，BatchNorm层</li><li>生成器的CNN网络使用U-Net结构，并采用skip连接</li><li>使用Markovian判别器(PatchGAN)，更加关注于图像局部信息</li></ul><h2 id="experiment">Experiment</h2><p>基于CGAN的原理，利用MNIST数据集，输入为图像的标签和噪声，生成图像，判断生成图像的标签和真实图像标签是否相同。原始图像如图3(a)所示，生成图像如图3(b)所示。可以看出，生成图像的数字和原始数据是相似的。</p><p>代码链接：<a href="https://github.com/FrankMartinem/Algorithm">CGAN代码</a></p><figure><img src="/img/Conditional-Generative-Adversarial-Nets/4.jpg" alt=""><figcaption>图3: (a) 原始图像；(b) 解码图像</figcaption></figure><h2 id="summary">Summary</h2><p>CGAN相较于GAN，加入了label，使得数据生成更加可控，生成的数据和label更加相关。</p><h2 id="references">References</h2><ol type="1"><li><p>Mirza M, Osindero S. Conditional generative adversarial nets[J]. arXiv preprint arXiv:1411.1784, 2014.</p></li><li><p>Isola P, Zhu J Y, Zhou T, et al. Image-to-image translation with conditional adversarial networks[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2017: 1125-1134.</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="DEEP LEARNING" scheme="http://zijunwan.github.io/categories/DEEP-LEARNING/"/>
    
    
    <category term="CGAN" scheme="http://zijunwan.github.io/tags/CGAN/"/>
    
  </entry>
  
  <entry>
    <title>Generative Adversarial Nets</title>
    <link href="http://zijunwan.github.io/2021/12/23/DeepLearning/Generative-Adversarial-Nets/"/>
    <id>http://zijunwan.github.io/2021/12/23/DeepLearning/Generative-Adversarial-Nets/</id>
    <published>2021-12-23T10:40:39.000Z</published>
    <updated>2024-12-15T11:40:06.424Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>本文将介绍对抗生成网络（GAN）的基础框架，以及主要的推导过程。首先是GAN的基本概念：GAN的主要思想是博弈。利用生成器<span class="math inline">\(G\)</span>和判别器<span class="math inline">\(D\)</span>的博弈。来使得生成器能够准确生成出类似于原始数据分布的样本；同时在博弈过程中，使得判别器能更加准确的区分出原始数据和生成数据。</p><h2 id="method">Method</h2><p>假设有一组样本<span class="math inline">\(data\)</span>，其数据分布为<span class="math inline">\(p_{data}\)</span>。生成器<span class="math inline">\(G\)</span>根据一组噪声数据<span class="math inline">\(z\)</span>，其分布为<span class="math inline">\(p_z\)</span>，生成一组数据<span class="math inline">\(G(z)\)</span>，判别器为<span class="math inline">\(D\)</span>。其中生成器和判别器的参数分别为<span class="math inline">\(\theta_{g}\)</span>和<span class="math inline">\(\theta_{d}\)</span>。那么，生成器的目标是使得生成的数据<span class="math inline">\(G(z)\)</span>更接近真实数据分布<span class="math inline">\(p_{data}\)</span>，也就是说<span class="math inline">\(log[D(G(z))]\)</span>要尽可能大。然后对于判别器<span class="math inline">\(D\)</span>，其对于真实数据的判别要更准确，即<span class="math inline">\(log[D(x)]\)</span>要尽可能大。所以，根据上述问题可以构造以下条件：</p><p><span class="math display">\[\underset{G}{min} \underset{D}{max} E_{x \sim p_{data}(x)}[log(D(x))] + E_{z \sim p_{z}[log(1-D(G(z)))]}\]</span></p><p>Goodfellow的论文中给出了下面的图，可以解释GAN的迭代过程。蓝线是判别器输出的数据分布；绿线是生成器输出的数据分布；黑线是真实的数据分布；<span class="math inline">\(z\)</span>是噪声数据，通过生成器映射到数据<span class="math inline">\(x\)</span>。从而计算生成器输出的分布。在一开始，生成器<span class="math inline">\(G\)</span>的输出分布和真实的分布差距很大，判别器可以很轻易的区分生成数据和真实数据；但是也仅限于中间的部分，对于两者重合的部分，判别器的区分效果并不好；然后在(b)图中，对判别器参数进行迭代优化（后面会证明，判别器的参数存在最优解），使得判别器的输出结果更加稳定平滑也更加准确；(c)图中迭代了生成器的参数，使得生成的数据更接近真实数据。如此循环迭代后，最理想的状态即是达到(d)图，判别器无法区分生成数据和真实数据，生成数据的分布和真实数据相等。</p><figure><img src="/img/Generative-Adversarial-Nets/1.png" alt=""><figcaption>图-1: GAN的迭代过程</figcaption></figure><p>所以GAN的训练过程如图-2所示：</p><figure><img src="/img/Generative-Adversarial-Nets/2.jpg" alt=""><figcaption>图-2: GAN算法</figcaption></figure><p>GAN的上述迭代过程能找到使得<span class="math inline">\(G(z)\)</span>的分布<span class="math inline">\(p_g\)</span>更接近<span class="math inline">\(p_{data}\)</span>的最优解，必须满足以下条件：</p><ol type="1"><li>上述最优化问题有唯一解（全局最优解）<span class="math inline">\(G^{*}\)</span>，且该解满足<span class="math inline">\(p_g=p_{data}\)</span></li><li>上述最优化问题最终收敛（条件-1的必要条件）</li></ol><p>要证明上述条件成立，可以先证明在生成器<span class="math inline">\(G\)</span>固定时，判别器<span class="math inline">\(D\)</span>的参数具有最优解（根据算法-1的迭代过程来推导），证明如下所示。（主要是第二项，这里并不是换元转换，因为<span class="math inline">\(G\)</span>并不一定可逆，这里是基于Radon-Nikodym定理。具体证明方法这里不深究）。</p><p><span class="math display">\[V(G, D) = \int_{x}p_{data}(d)log(D(x))dx + \int_{z}p_z(z)log(1-D(G(z)))dz\]</span> <span class="math display">\[=\int_{x}p_{data}(d)log(D(x)) + p_{g}p_g(x)log(1-D(x)) dx\]</span></p><p>要使得<span class="math inline">\(V(G, D)\)</span>取得最大值，<span class="math inline">\(D(x)\)</span>就需要使函数<span class="math inline">\(f(D) = p_{data}log(D) + p_{g}log(1-D)\)</span>取最大值，根据拉格朗日中值定理，可以计算得到：取最大值的<span class="math inline">\(D(x)\)</span>应该满足<span class="math inline">\(D^{*}(x) = \frac{p_{data}}{p_{data}+p_{g}}\)</span>。所以，生成器<span class="math inline">\(G\)</span>固定时，判别器<span class="math inline">\(D\)</span>的参数具有最优解，该最优解满足<span class="math inline">\(D(x) = \frac{p_{data}}{p_{data}+p_{g}}\)</span></p><p>然后，需要证明当且仅当<span class="math inline">\(p_g=p_{data}\)</span>时，训练函数<span class="math inline">\(C(G) = \underset{D}{max}V(G, D)\)</span>取得全局最小值。证明如下： 当<span class="math inline">\(p_g=p_{data}\)</span>，根据上述推导可知<span class="math inline">\(D(x) = \frac{1}{2}\)</span>。带入到<span class="math inline">\(V(G, D)\)</span>中，可得：</p><p><span class="math display">\[V(G, D^*) = \int_{x}p_{data}(x)log(\frac{1}{2})+p_{g}(x)log(1-\frac{1}{2})dx\]</span> <span class="math display">\[ = -log(2)\int_{x}p_{data}(x)dx-log(2)\int_{x}p_{g}(x)dx\]</span> <span class="math display">\[ = -log(2) - log(2) = -log(4)\]</span></p><p>（概率的积分是1）所以当<span class="math inline">\(p_g=p_{data}\)</span>时，训练函数的值是<span class="math inline">\(-log(4)\)</span>，下面需要证明这是最小值，且只有<span class="math inline">\(p_g=p_{data}\)</span>时条件才成立。于是我们假设<span class="math inline">\(p_g \neq p_{data}\)</span>。但是判别器<span class="math inline">\(D\)</span>仍旧取得最优解。所以有：</p><p><span class="math display">\[V(G, D^*) = \int_{x}p_{data}(x)log(\frac{p_{data}}{p_{data}+p_{g}}) + p_{g}(x)log(\frac{p_{g}}{p_{data}+p_{g}})dx\]</span> <span class="math display">\[= \int_{x}(log(2)-log(2))p_{data}(x) + p_{data}(x)log(\frac{p_{data}}{p_{data}+p_{g}}) + \]</span> <span class="math display">\[ \int_{x}(log(2)-log(2))p_{g}(x) + p_{g}(x)log(\frac{p_{g}}{p_{data}+p_{g}})dx\]</span> <span class="math display">\[= -log(2)\int_{x}p_{g}(x)+p_{data}(x)dx + \int_{x}p_{data}(x)(log(2)+log(\frac{p_{data}}{p_{data}+p_{g}}))dx + \]</span> <span class="math display">\[ \int_{x}p_{g}(log(2) + log(\frac{p_{g}}{p_{data}+p_{g}})dx\]</span> <span class="math display">\[= -log(4) + \int_{x}p_{data}(x)log(\frac{p_{data}}{(p_{data}+p_{g})/2})) + \int_{x}p_{g}(x)log(\frac{p_{g}}{(p_{data}//2+p_{g})/2})\]</span></p><p>根据KL散度的定义，可以得到：</p><p><span class="math display">\[V(G, D^*) = -log(4) + KL(p_{data}|\frac{p_{data}+p_{g}}{2}) + KL(p_{g}|\frac{p_{data}+p_{g}}{2})\]</span></p><p>由于<span class="math inline">\(KL(p|q) \geq 0\)</span>，所以<span class="math inline">\(V(G, D)\)</span>当且仅当<span class="math inline">\(p_{data}=p_{g}\)</span>时取得最小值<span class="math inline">\(-log(4)\)</span>。 <span class="math inline">\(KL(p_{data}|\frac{p_{data}+p_{g}}{2}) + KL(p_{g}|\frac{p_{data}+p_{g}}{2}) = JSD(p_{data}|p_{g}\)</span>，论文中是根据Jensen–Shannon散度来计算的。结论是一致的。</p><p>最后是关于<span class="math inline">\(C(G) = V(G, D)\)</span>的收敛的证明。论文中的证明主要是根据导数的特性，以及分布<span class="math inline">\(p_{g}\)</span>属于凸函数的特点来证明的。</p><h2 id="experiment">Experiment</h2><p>基于GAN的原理，本文使用MNIST数据集进行实验。判断GAN是否能生成和MNIST数据集很像的图像。 <a href="https://github.com/FrankMartinem/Algorithm">代码链接</a>。原始的MNIST数据如图3(a)所示。生成的数据如图4所示。</p><p><img src="/img/Generative-Adversarial-Nets/3.jpg" alt="图3：MNIST原始数据"> <img src="/img/Generative-Adversarial-Nets/4.png" alt="图4：GAN生成的数据"></p><h2 id="summary">Summary</h2><p>以上就是最基础的GAN的概念以及推导过程。尽管已经证明了GAN的推导过程的可行性。但是在实际应用中，要使得GAN收敛并得到好的效果，还需要一些训练技巧。 - 首先是GAN的收敛问题，虽然已经证明GAN的迭代函数是收敛的，但是收敛的前提是生成器函数为凸函数。且由于神经网络迭代的特性。我们无法确定神经网络是通过何种策略调整，来达到纳什均衡的（也就是GAN有很好的表现的状态，论文中的观点）。 - 然后是<span class="math inline">\(p_{g}\)</span>没办法显示表示，因为是生成器的输出。然后是<span class="math inline">\(p_{data}\)</span>未知，虽然可以根据这一分布计算<span class="math inline">\(D\)</span>的最优解，但是并没有办法求出具体数值。</p><h2 id="references">References</h2><p>[1] Goodfellow et al., 2014. Generative Adversarial Nets.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="DEEP LEARNING" scheme="http://zijunwan.github.io/categories/DEEP-LEARNING/"/>
    
    
    <category term="GAN" scheme="http://zijunwan.github.io/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://zijunwan.github.io/2021/12/20/hello-world/"/>
    <id>http://zijunwan.github.io/2021/12/20/hello-world/</id>
    <published>2021-12-19T23:04:45.831Z</published>
    <updated>2024-12-15T10:31:30.360Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo new <span class="hljs-string">"My New Post"</span></span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo server</span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo generate</span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo deploy</span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Bypy pack的使用</title>
    <link href="http://zijunwan.github.io/2021/12/14/Software/Bypy-tutorial/"/>
    <id>http://zijunwan.github.io/2021/12/14/Software/Bypy-tutorial/</id>
    <published>2021-12-14T02:07:05.000Z</published>
    <updated>2024-12-15T11:49:19.225Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景">背景</h2><p>网页上的一些资料，有一些是存储在百度网盘的。一些大文件下载时，需要安装百度网盘客户端。有时候在一些虚拟机，或者Linux服务器端没有GUI桌面的情况下，下载文件就会很不方便。而且很多时候我也不想安装百度网盘的客户端，感觉很难用。所以希望有一种能用命令行下载百度网盘文件的方式。</p><p>经过搜索后，发现了一个python的包Bypy，能在终端下载百度网盘的文件。这里记录一下Bypy的使用方式，方便以后查询。</p><h2 id="使用方法">使用方法</h2><ol type="1"><li><p>安装</p><p>安装方式跟普通的python包一样：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install bypy<br></code></pre></td></tr></tbody></table></figure><p>在离线状态下，可以在pypi官网下载bypy的whl文件，同样通过pip安装</p></li><li><p>初始化</p><p>初次使用时，需要授权bypy访问自己的百度网盘信息。Byby包并不能直接下载任意的百度网盘文件，需要先存储到自己的网盘的特定路径。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bypy info<br></code></pre></td></tr></tbody></table></figure><p>打开命令行弹出的网页，登录百度账号，然后复制授权码，等待bypy连接百度网盘。连接完成后，会显示百度网盘的已用空间和总空间。这里注意，可能会出现无响应或者连接失败的情况，这时使用pip卸载bypy再重新安装，也还是会用之前的授权码继续尝试连接，这时需要删除.bypy文件夹中的bypy.json文件，授权码时存储在这里的。</p></li><li><p>下载文件</p><p>bypy包只能读取百度网盘中apps/bypy/文件夹下的文件，所以将需要下载的文件移动到这个文件夹，然后再下载或者上传文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">bypy list  # 显示文件夹的中文件<br>bypy download [remote] [local path]  # 下载文件或者文件夹<br>bypy downfile &lt;remote file&gt; [local path]  # 下载文件<br>bypy downdir &lt;remote dir&gt; [local dir]  # 下载整个文件夹<br>bypy upload [local path] [remote path]  # 上传文件或文件夹（上传时百度网盘会检查文件校验，如果已经收录过，则秒传<br>bypy syncup [local path] [remote path]  # 同上<br></code></pre></td></tr></tbody></table></figure></li><li><p>下载加速</p><p>bypy默认的下载器，并不能达到最大下载速度。百度非会员下载已经很慢了，所以最好是换其他的下载器。bypy支持的第三方下载器只有aria2。我们可以安装aria2。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install aria2<br></code></pre></td></tr></tbody></table></figure><p>安装完aria2之后，在bypy的参数中设置使用的下载器，使用--downloader参数设置，--downloader-arguments可以设置下载器的参数，这里不细究了，用默认就可以</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">bypy <span class="hljs-attr">--downloader</span> aria2 download <span class="hljs-selector-attr">[remote]</span> <span class="hljs-selector-attr">[local path]</span> <br></code></pre></td></tr></tbody></table></figure><p>然后等文件下载就可以了。这里需要注意的是，由于文件一般都比较大，而且百度网盘下载的又慢，所以最好配合tmux一起使用，防止下载过程突然中断。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SOFTWARE" scheme="http://zijunwan.github.io/categories/SOFTWARE/"/>
    
    
    <category term="python" scheme="http://zijunwan.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>服务器非管理员配置python环境</title>
    <link href="http://zijunwan.github.io/2021/12/14/Software/Config-Python-for-Unroot-Users/"/>
    <id>http://zijunwan.github.io/2021/12/14/Software/Config-Python-for-Unroot-Users/</id>
    <published>2021-12-14T02:07:05.000Z</published>
    <updated>2024-12-15T11:41:45.591Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>Linux服务器配置python环境时，默认的安装位置是"/usr/bin"。但没有管理员权限时是无法写文件到当前路径的。而且多人共用一个服务器时，大家的python环境各不相同，每个人也会配置自己的python环境。所以在home文件夹安装配置自己的python环境是更合适的。一下是在没有root权限的情况下配置python的方法。</p><h2 id="method">Method</h2><ol type="1"><li>下载python source code到home/your name 文件夹。这里以python-3.10.1为例，可以从<a href="https://www.python.org/downloads/source/">python官网</a>下载对应版本的源代码</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://www.python.org/ftp/python/3.10.1/Python-3.10.1.tgz<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>解压文件</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd download dir<br>tar -xzvf Python-3.10.1.tgz<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li><p>下载好以后，如果直接安装，会有以下的问题：首先是openssl，用于软件的安全通信，避免被窃听的一个toolkit。一般是系统级的app；然后是zlib，这个组件用于数据压缩和解压，如果需要使用科学计算的库，那么zlib是必须的；最后是libffi，相当于C的编译器，同样也是用于科学计算。上述组件均可以通过管理员sudo，yum安装。但是如果没有管理员权限，那么需要自行安装。</p></li><li><p>安装openssl</p></li></ol><p>下载并解压<a href="https://www.openssl.org/source/">openssl</a></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://www.openssl.org/source/openssl-3.0.0.tar.gz<br>tar -xzvf openssl-3.0.0.tar.gz<br></code></pre></td></tr></tbody></table></figure><p>编译并安装</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd openssl-3.0.0.tar.gz<br>./config --prefix=/home/your name/openssl_dir<br>make -j48 <br>make install<br></code></pre></td></tr></tbody></table></figure><ol start="5" type="1"><li>安装<a href="http://www.zlib.net/">zlib</a></li></ol><p>下载，解压，编译并安装</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://www.zlib.net/zlib-1.2.11.tar.gz<br>tar -xzvf zlib-1.2.11.tar.gz<br>cd zlib-1.2.11.tar.gz<br>./configure --prefix=/home/your name/zlib_dir<br>make -j48<br>make install<br></code></pre></td></tr></tbody></table></figure><ol start="6" type="1"><li>安装<a href="https://github.com/libffi/libffi/releases">libffi</a></li></ol><p>下载，解压，编译并安装</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/libffi/libffi/releases/download/v3.4.2/libffi-3.4.2.tar.gz<br>tar -xzvf libffi-3.4.2.tar.gz<br>cd libffi-3.4.2.tar.gz<br>./configure --prefix=/home/your name/libffi<br>make -j48<br>make install<br></code></pre></td></tr></tbody></table></figure><ol start="7" type="1"><li>将上述安装文件的路径写入环境变量</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/your name/libffi_dir/lib/pkgconfig<br>export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/home/your_name/openssl_dir/lib:/home/your name/zlib_dir/lib:/home/your_name/libffi_dir/lib<br>export PKG_CONFIG_PATH=/home/jacob/libffi/lib/pkgconfig<br>export CFLAGS=-I/home/your name/libffi_dir/include<br>export LDFLAGS=-L/home/your name/libffi_dir/lib<br></code></pre></td></tr></tbody></table></figure><ol start="8" type="1"><li>进入python的setup文件，修改部分编译信息</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd python_path/Modules/<br>vim Setup.dist<br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消下面的注释</span><br>SSL=/home/your name/openssl_dir<br>_ssl _ssl.c -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl -L$(SSL)/lib -lssl -lcrypto<br>zlib zlibmodule.c -I/home/your name/zlib_dir/include -L/home/your name/zlib_dir/lib -lz<br></code></pre></td></tr></tbody></table></figure><ol start="9" type="1"><li>编译python代码，这里需要gcc编译器，一般Linux发行版都自带gcc编译器，如果没有安装，请联系管理员。同时，编译过程需要配置特定的参数</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd Python-3.10.1<br>./configure LDFLAGS="-L/home/your name/libffi_dir/lib64 -Wl,--rpath=/home/your name/libffi_dir/lib64" CFLAGS="-I/home/your name/libffi_dir/include" PKG_CONFIG_PATH="${libffi}/lib/pkgconfig" --prefix=/home/your name/your path --with-openssl=/home/your name/openssl_dir<br>make # make -j48 这里不推荐，因为会编译所有的test file，耗时较长，机器快的话也要20min-30min左右<br>make install<br></code></pre></td></tr></tbody></table></figure><h2 id="summary">Summary</h2><p>以上就是非管理员账户在home文件夹安装自己的python环境的方法。这种方法能安装简易的python环境，但是如果需要很复杂的计算，例如scikt，pytorch，tensorflow等强烈依赖底层C链接库的模块，那么上述方法或许可行。因为整个过程无非是把库文件的源代码安装到了home文件夹里，然后修改环境变量配置。但是如果真的是很复杂的编译和依赖，不建议使用上述方法。上述方法主要参考以下博客和文章：</p><ol type="1"><li><a href="https://blog.csdn.net/u012440550/article/details/109371016">CSDN</a></li><li><a href="https://stackoverflow.com/questions/65691539/locally-compiled-libffi-files-not-getting-picked-up-while-recompiling-python-3-p">Stackoverflow</a></li><li><a href="https://hellovimo.github.io/uvm_testbench_gen/localpythoninstall.html">Github Pages</a></li></ol><p>那么，针对Introduction提出的问题，每个人都需要自定义自己的python环境，是否有更好的解决方法呢。答案是<strong>有的</strong>，那就是由管理员安装python到usr目录。然后每个人可以在home文件夹新建自己的虚拟环境。只需要使用pip3命令即可：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 -m pip install --user virtualenv<br>python3 -m venv /home/your name/python_dir<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SOFTWARE" scheme="http://zijunwan.github.io/categories/SOFTWARE/"/>
    
    
    <category term="linux" scheme="http://zijunwan.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>极大似然估计 - Log Likelihood</title>
    <link href="http://zijunwan.github.io/2021/12/05/MachineLearning/Log-Likelihood/"/>
    <id>http://zijunwan.github.io/2021/12/05/MachineLearning/Log-Likelihood/</id>
    <published>2021-12-05T12:23:33.000Z</published>
    <updated>2024-12-15T10:48:28.169Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>极大似然估计是传统机器学习以及深度学习中都常用的计算方法。其主要的目的，是根据现有的数据分布，估计采样得到现有数据的更大的数据集的分布。</p><h2 id="method">Method</h2><h3 id="定义">定义</h3><p>假设从一个很大的数据集中采集到有<span class="math inline">\(m\)</span>个数据的数据集<span class="math inline">\(X=\{x_1,...,x_m\}\)</span>。所以原始的很大的数据集的分布为<span class="math inline">\(P_{data}(x)\)</span>。根据数据计算得到的分布为<span class="math inline">\(P_{model}(x; \theta)\)</span>。其中<span class="math inline">\(\theta\)</span>是模型的参数。所以：</p><p><span class="math display">\[\theta= \underset{\theta}{\operatorname{arg max}}P_{model}(x;\theta)\]</span></p><p><span class="math display">\[\theta= \underset{\theta}{\operatorname{arg max}}\prod_{i=1}^{m}P_{model}(x_i;\theta)\]</span></p><p>这里直接计算概率连乘很不方便，而且容易出现极小值。由于log函数的单调性，且能处理连乘问题，所以这里取对数。</p><p><span class="math display">\[\theta = \underset{\theta}{\operatorname{arg max}}\sum_{i=1}^{m}log(P_{model}(x_i; \theta))\]</span></p><p>求和符号的计算仍旧存在些许不方便，所以这里缩放<span class="math inline">\(m\)</span>倍，且数据从当前数据集中提取，当前数据集的经验分布设为<span class="math inline">\(\hat{P_{data}}\)</span>。 所以： <span class="math display">\[\theta=\underset{\theta}{\operatorname{arg max}} E_{x \sim \hat{P_{data}}}(P_{model}(x;\theta))\]</span></p><p>以上就是极大似然函数。</p><h3 id="kl散度视角">KL散度视角</h3><p>根据问题的描述，我们需要求解数据的分布<span class="math inline">\(P_{model}(x; \theta)\)</span>，使得其最接近数据集的分布<span class="math inline">\(\hat{P_{data}}(x)\)</span>。从KL散度出发，即需要最小化两者的KL散度（注意：KL散度计算是有顺序的，即<span class="math inline">\(D_{KL}(P||Q) \neq D_{KL}(Q||P)\)</span>。 KL散度计算如下：</p><p><span class="math display">\[D_{KL}(P_{data}(x)|| P_{model}(x; \theta))=E_{x\sim\hat P_{data}}[log(\hat P_{data}(x)) - log(P_{model}(x; \theta))]\]</span></p><p>第一项和模型参数无关，所以计算时只需要最小化第二项，即： <span class="math display">\[\theta = \underset{\theta}{\operatorname{arg max}} -log(P_{model}(x; \theta))\]</span></p><p>这一步骤和定义中的最大化是相同的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="MACHINE LEARNING" scheme="http://zijunwan.github.io/categories/MACHINE-LEARNING/"/>
    
    
    <category term="probability" scheme="http://zijunwan.github.io/tags/probability/"/>
    
  </entry>
  
  <entry>
    <title>基于SVD算法的无迹卡尔曼滤波</title>
    <link href="http://zijunwan.github.io/2021/09/24/MachineLearning/SVD-UKF/"/>
    <id>http://zijunwan.github.io/2021/09/24/MachineLearning/SVD-UKF/</id>
    <published>2021-09-24T11:52:00.000Z</published>
    <updated>2024-12-15T10:49:22.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题">问题</h2><p>无迹卡尔曼滤波（Unscented Kalman Filter）是卡尔曼滤波（Kalman Filter）的改进版，其中取消了卡尔曼滤波中对于观测变量的一阶线性隐马尔可夫链的约束，也取消了观测变量和测量变量之间的线性关系。取而代之的是任意的函数，然后用无迹变换（Unscented Transform）来估计观测变量变化时以及观测变量和测量变量变化时的概率分布变化。但是，无迹卡尔曼滤波在计算时需要计算协方差矩阵的Cholesky分解，这一步需要保证协方差矩阵是正定矩阵。在真实计算中，由于观测变量可能有多维，且互相之间可能互相独立，导致协方差矩阵不一定是正定矩阵。也有可能由于参数的选择不当，导致协方差矩阵不满足正定矩阵的要求。从而导致计算无法进行。这也是无迹卡尔曼滤波中需要注意的地方。</p><h2 id="解决方法">解决方法</h2><p>对于协方差矩阵非正定的问题，目前有两种解决办法。一种是选择合适的参数。但是这种方法比较依赖经验，需要多次测试调整。第二种方法就是基于SVD的无迹卡尔曼滤波。这种方法利用奇异值分解（SVD）方法，将协方差矩阵分解为对角矩阵和另外两个矩阵。由于协方差矩阵中，对角线上的值一定是正的，因为对角线上的值就是不同维度的观测变量的方差。所以对角矩阵的值肯定是正的，所以可以开根号。协方差矩阵分解的计算方法如下：</p><p><span class="math display">\[[S, V, D] = SVD(P)\]</span> <span class="math display">\[P_{est} = S * \sqrt{V}\]</span></p><p>用上述步骤，替换无迹卡尔曼滤波计算中的Cholesky分解，即得到基于SVD的无迹卡尔曼滤波。因为协方差矩阵是对称的，所以<span class="math inline">\(S\)</span>的转置矩阵是<span class="math inline">\(D\)</span>，计算时只考虑一边即可。其余的计算步骤参考Unscented Kalman Filter。</p><h2 id="参考文献">参考文献</h2><ol type="1"><li>An Improved Unscented Kalman Filter Algorithm for Radar Azimuth Mutation</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="MACHINE LEARNING" scheme="http://zijunwan.github.io/categories/MACHINE-LEARNING/"/>
    
    
    <category term="SVD-UKF" scheme="http://zijunwan.github.io/tags/SVD-UKF/"/>
    
  </entry>
  
  <entry>
    <title>SSH Download and Upload</title>
    <link href="http://zijunwan.github.io/2021/08/13/Software/SSH-Download-and-Upload/"/>
    <id>http://zijunwan.github.io/2021/08/13/Software/SSH-Download-and-Upload/</id>
    <published>2021-08-13T01:34:41.000Z</published>
    <updated>2023-12-04T08:42:17.344Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ssh-从服务器下载文件或者上传文件以及文件夹">SSH 从服务器下载文件或者上传文件以及文件夹</h1><ol type="1"><li>从服务器下载文件</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp yourname@IP address:/path to your file/ /local path/<br>scp frank@10.212.48.177:~/Downloads/test.py ~/Downloads<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>从服务器下载文件夹</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r yourname@IP address:/path to your folder/ /local path/<br>scp -r frank@10.212.48.177:~/Downloads/test ~/Downloads<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>上传文件到服务器</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /path to your file/ yourname@IP address:/remote path/<br>scp ~/Downloads/test.py frank@10.212.48.177:~/Downloads<br></code></pre></td></tr></tbody></table></figure><ol start="4" type="1"><li>上传文件夹到服务器</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r /path to your folder/ yourname@IP address:/remote path/<br>scp -r ~/Downloads/test frank@10.212.48.177:~/Downloads<br></code></pre></td></tr></tbody></table></figure><p>注意，服务器的IP地址后的冒号和文件地址，文件夹地址之间没有空格</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="DEVELOPMENT" scheme="http://zijunwan.github.io/categories/DEVELOPMENT/"/>
    
    
    <category term="ssh" scheme="http://zijunwan.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>git下载仓库的单个文件</title>
    <link href="http://zijunwan.github.io/2021/08/12/Software/Git-Clone-Part-of-Repository/"/>
    <id>http://zijunwan.github.io/2021/08/12/Software/Git-Clone-Part-of-Repository/</id>
    <published>2021-08-12T02:36:05.000Z</published>
    <updated>2024-12-15T11:33:47.869Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述">问题描述</h2><p>如果一个仓库的文件很多，但是又只需要其中的一部分，这时下载全部的文件会很浪费时间，毕竟github的下载速度也慢。所以就需要想办法只下载部分文件。下面介绍三种方法。</p><h2 id="git指令下载">git指令下载</h2><p>git目前已经支持通过修改配置文件来下载单个文件，这里以我自己的仓库为例，项目仓库结构如图所示。我需要下载Algorithm项目下的Kalman整个文件夹，以及Wiener-Filter文件夹下的wienerfilter.py文件。那么可以通过如下方法实现。</p><figure><img src="/img/Git-Clone-Part-of-Repository/1.png" alt=""><figcaption>项目截图</figcaption></figure><ol type="1"><li>首先新建一个文件夹，然后clone整个仓库的结构以及git的改动文件。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir file<br>cd file<br>git init<br>git remote add -f origin &lt;url of target repository&gt;<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>然后配置git config文件，将sparsecheckout设置为true，即允许从仓库中下载部分的文件</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config core.sparseCheckout true<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>将你需要下载的文件添加到config文件中，对于例子中的要求，配置如下</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo "Kalman" &gt;&gt; .git/info/sparse-checkout<br>echo "Wiener-Filter/wienerfilter.py" &gt;&gt; .git/info/sparse-checkout<br></code></pre></td></tr></tbody></table></figure><ol start="4" type="1"><li>然后直接拉取项目，然后会根据配置文件拉取对应的文件</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull origin master<br></code></pre></td></tr></tbody></table></figure><p>命令行截图如图所示</p><figure><img src="/img/Git-Clone-Part-of-Repository/2.png" alt=""><figcaption>命令行截图</figcaption></figure><p>可以看出，最终只下载了需要的代码。详细的git sparse checkout的配置可以查询git官方文档[link]</p><h2 id="网页工具">网页工具</h2><p>可以通过<a href="https://minhaskamal.github.io/DownGit/#/home">这个网站</a>下载某个项目的部分文件，只需要把对应文件或文件夹的链接复制到下载框中即可。注意这里用的是网页链接，而不是仓库的url</p><figure><img src="/img/Git-Clone-Part-of-Repository/3.png" alt=""><figcaption>网页截图</figcaption></figure><h2 id="用svn配置只下载部分文件">用SVN配置只下载部分文件</h2><p>找到对应的文件夹，然后修改链接中的/tree/master/为/trunk/。例如例子中的Kalman文件夹链接为 https://github.com/FrankMartinem/Algorithm/tree/master/Kalman</p><p>修改为</p><p>https://github.com/FrankMartinem/Algorithm/trunks/Kalman</p><p>然后运行svn checkout命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">svn checkout https://github.com/FrankMartinem/Algorithm/trunk/Kalman<br></code></pre></td></tr></tbody></table></figure><p>然后就可以下载对应文件夹的文件了。如果下载的文件夹不在master分支上，那么需要找到对应的分支，然后修改为/branches/branchname/。例如在develop分支上，则修改为/branches/develop/。</p><h2 id="总结">总结</h2><p>以上就是三种下载单个文件的方法，笔者尝试了前两种方法，均能实现需求。由于笔者没有装svn，所以没有尝试svn方法，但是有很多人也尝试过这种方法，应该是可行的。</p><p>总体来看，三种方法各有优劣，git checkout方法配置麻烦，但是能同时下载多个不同位置的文件或者文件夹，只需要写好配置文件。但是如果项目文件很复杂，层级很多，而且git记录很多的话，那么第一步初始化就要花很长的时间。 网页版的话更方便快捷，但是对于复杂的需求，可能需要复制很多次网页链接然后下载很多次，会比较麻烦。而且这种方法依赖于浏览器和图形界面。</p><p>svn方法可能和网页版的缺点类似，也是只能针对单一文件夹设置。当然也可能svn还有其他的功能，这里不过多赘述。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="DEVELOPMENT" scheme="http://zijunwan.github.io/categories/DEVELOPMENT/"/>
    
    
    <category term="git" scheme="http://zijunwan.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Linux下解压window中的zip文件的乱码问题</title>
    <link href="http://zijunwan.github.io/2021/07/29/Software/Linux-unzip-file-from-Windows/"/>
    <id>http://zijunwan.github.io/2021/07/29/Software/Linux-unzip-file-from-Windows/</id>
    <published>2021-07-29T12:51:07.000Z</published>
    <updated>2024-12-15T11:42:05.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在windows系统下压缩的zip文件，使用的编码格式是gbk，而Linux默认是utf-8的，所以解码后如果有中文，会出现乱码。解决方法就是利用unzip命令解压。然后设置好编码参数，解压命令如下。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip -O cp936 file-name.zip<br></code></pre></td></tr></tbody></table></figure><p>解压文件会显示在当前目录下，如果想解压到指定文件夹，可以自行修改参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SOFTWARE" scheme="http://zijunwan.github.io/categories/SOFTWARE/"/>
    
    
    <category term="linux" scheme="http://zijunwan.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Latex+Vscode Configuration in Ubuntu</title>
    <link href="http://zijunwan.github.io/2021/07/28/Software/Latex-Vscode-Configuration-in-Ubuntu/"/>
    <id>http://zijunwan.github.io/2021/07/28/Software/Latex-Vscode-Configuration-in-Ubuntu/</id>
    <published>2021-07-28T02:44:38.000Z</published>
    <updated>2024-12-15T11:41:55.772Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ubuntu下latex安装以及vscode配置">Ubuntu下Latex安装以及vscode配置</h1><p>本文主要介绍Ubuntu系统下Latex环境的配置，使用的软件有 - TexLive2021 - vscode</p><h2 id="安装texlive">安装TexLive</h2><ol type="1"><li><p>下载TexLive安装包，下载地址为：[TexLive][https://www.tug.org/texlive/acquire-netinstall.html]。官网下载可能会比较慢，可以选择国内镜像网站：[TexLive Tsinghua Mirror][https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/]。</p></li><li><p>解压对应的iso文件，Ubuntu18.04可以直接右键解压。也可以用mount命令挂载iso文件然后提取文件，这样会比较麻烦，这里也不多赘述。解压完后，文件内容如图1所示。 <img src="/img/Latex-Vscode-Configuration-in-Ubuntu/1.png"></p></li><li><p>cd到对应的文件目录，然后运行如下命令，可以在命令行中安装，如图2所示。根据提示，配置好需要安装的组件，然后回车安装即可。</p></li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ./install-tl<br></code></pre></td></tr></tbody></table></figure><p><img src="/img/Latex-Vscode-Configuration-in-Ubuntu/2.png"></p><ol start="4" type="1"><li>也可以用图形界面安装。先cd到对应文件目录，然后运行如下命令，就会显示和windows类似的图形界面了，如图3所示。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ./install-tl -gui -repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/<br></code></pre></td></tr></tbody></table></figure><p><img src="/img/Latex-Vscode-Configuration-in-Ubuntu/3.png"></p><p>建议对于大多数用户，安装完整版的TexLive，省得以后发现缺少依赖不能编译，会很麻烦。TexLive的安装较慢，耐心等待。安装完成后，在terminal中输入xelatex，latexmk等命令，如果显示command not found。那么需要添加TexLive到环境变量，添加的方法如下。如果显示有当前命令，那么直接到vscode配置部分。</p><h2 id="添加环境变量">添加环境变量</h2><p>找到对应的终端配置文件，如果是zsh则是.zshrc，如果是bash则是.bashrc。都在用户目录下。打开终端，输入如下命令。如果是其他shell则改成其他shell的配置文件，用不习惯vim可以用gedit。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim ~/.zshrc<br></code></pre></td></tr></tbody></table></figure><p>在配置文件中加入如下内容：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH="$PATH:/usr/local/texlive/2021/bin/x86_64-linux/"<br>export MANPATH="$MANPATH:/usr/local/texlive/2018/texmf-dist/doc/man"<br>export INFOPATH="$INFOPATH/usr/local/texlive/2018/texmf-dist/doc/info"<br></code></pre></td></tr></tbody></table></figure><p>配置环境变量需要注意的内容，可以参考另外一篇 [blog][https://frankmartinem.github.io/2021/06/01/Linux-Environment-Variable/]</p><p>配置完成后，打开终端输入xelatex，latexmk等命令，检查环境变量是否配置成功。</p><h2 id="vscode配置">vscode配置</h2><p>TexLive安装完成后，vscode的配置就比较简单了。主要包括以下步骤。 1. 安装Latex Workshop插件，在vscode的扩展商店里，直接搜索就能找到。</p><ol start="2" type="1"><li>配置Latex编译的json文件。安装好插件以后，需要配置好编译的一些参数，这里提供我自己的配置文件</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs shell">"latex-workshop.latex.tools":<br>[<br>    {<br>    "name": "latexmk",<br>    "command": "latexmk",<br>    "args": [<br>        "-synctex=1",<br>        "-interaction=nonstopmode",<br>        "-file-line-error",<br>        "-pdf",<br>        "%DOC%"<br>    ]<br>    },<br>    {<br>    "name": "xelatex",<br>    "command": "xelatex",<br>    "args": [<br>        "-synctex=1",<br>        "-interaction=nonstopmode",<br>        "-file-line-error",<br>        "%DOC%"<br>    ]<br>    },<br>    {<br>    "name": "pdflatex",<br>    "command": "pdflatex",<br>    "args": [<br>        "-synctex=1",<br>        "-interaction=nonstopmode",<br>        "-file-line-error",<br>        "%DOC%"<br>    ]<br>    },<br>    {<br>    "name": "bibtex",<br>    "command": "bibtex",<br>    "args": [<br>        "%DOCFILE%"<br>    ]<br>    }<br>],<br><br>"latex-workshop.latex.recipes":<br>[<br>    {<br>    "name": "latexmk",<br>    "tools": [<br>        "latexmk"<br>    ]<br>    },<br>    {<br>    "name": "xelatex -&gt; bibtex -&gt; xelatex*2",<br>    "tools": [<br>        "xelatex",<br>        "bibtex",<br>        "xelatex",<br>        "xelatex"<br>    ]<br>    },<br>    {<br>    "name": "xelatex",<br>    "tools": [<br>        "xelatex"<br>    ]<br>    },<br>    {<br>    "name": "pdflatex -&gt; bibtex -&gt; pdflatex*2",<br>    "tools": [<br>        "pdflatex",<br>        "bibtex",<br>        "pdflatex",<br>        "pdflatex"<br>    ]<br>    },<br>    {<br>        "name":"pdflatex",<br>        "tools": [<br>            "pdflatex"<br>        ]<br>    }<br>]<br></code></pre></td></tr></tbody></table></figure><p>主要的配置是latex的编译命令以及流程化的一些编译过程。latex.tools里面是常用的编译命令，例如latexmk，pdflatex，xelatex等，需要配置好这些命令的参数。latex.recipe主要是一些编译链，用于文档的编译。然后latex插件中显示的编译选项就是对应于latex.recipe的内容。例如这里比较常用的latexmk直接编译，以及涉及到参考文献引用的pdflatex-&gt;bibtex-&gt;pdflatex-&gt;pdflatex的编译链等。</p><p>以上就是Ubuntu下Latex环境配置以及vscode环境配置的主要内容了。配置完成后基本就能用了，还有一些其他的细节后续可以根据自己的习惯去添加。例如安装sumatra PDF插件，安装Latex英文词库语法插件等。最后，个人建议用vscode写latex时，很有必要开启自动换行，不然手动回车换行会很麻烦，而且后期改起来也很麻烦。打开的方式就是在vscode的设置中，找到Word Wrap选项，然后改成wordwrapcolumn。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SOFTWARE" scheme="http://zijunwan.github.io/categories/SOFTWARE/"/>
    
    
    <category term="linux" scheme="http://zijunwan.github.io/tags/linux/"/>
    
    <category term="latex" scheme="http://zijunwan.github.io/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统下连接校园网（ZJU VPN）</title>
    <link href="http://zijunwan.github.io/2021/07/28/Software/ZJU-VPN-connection-in-Linux/"/>
    <id>http://zijunwan.github.io/2021/07/28/Software/ZJU-VPN-connection-in-Linux/</id>
    <published>2021-07-28T02:04:24.000Z</published>
    <updated>2024-12-15T11:42:40.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="软件安装">软件安装</h2><p>在Linux系统下连接校园网和Windows稍有不同，需要使用命令行连接。但是基本过程是一样的，以下为主要步骤： 1. 设置系统的IP地址。如果有固定分配的IP，那么就在网络选项理设置IP地址。如图1所示。</p><p><img src="/img/ZJU-VPN-connection-in-Linux/1.png"></p><ol start="2" type="1"><li>安装xl2tpd。这是VPN设置必要的软件包，由于校园网是以VPN的形式搭建的，所以需要这个安装包，访问校内和校外网址。安装方法为如下命令：</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install xl2tpd<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>安装zjunet。这是zju vpn连接的命令行工具，是依赖xl2tpd的，所以需要先进行步骤2。软件的网址是：[zjunet][https://github.com/QSCTech/zjunet]。找到最新的release版本，然后下载安装包。以Ubuntu为例，下载*.deb文件，先cd到安装包所在路径，然后用如下命令安装：</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo dpkg -i *.deb<br></code></pre></td></tr></tbody></table></figure><ol start="4" type="1"><li>完成上述步骤后，终端输入zjunet可以查看对应的参数以及帮助文档，如图2所示。</li></ol><p><img src="/img/ZJU-VPN-connection-in-Linux/2.png"></p><p>以上就完成了对应软件安装，下面是zjunet的基本使用教程</p><h2 id="zjunet使用">zjunet使用</h2><p>zjunet的使用参数有很多，对大部分人来说，主要的应用场景应该还是连接校园网。所以下面只介绍如何连接校园网。主要有以下几步。</p><ol type="1"><li>输入你的账号和密码。先输入账号密码，软件会自动记录，下次登录时可以省略这步。配置命令如下。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zjunet user add<br></code></pre></td></tr></tbody></table></figure><p>然后终端会提示你输入账号和密码，如图3所示。</p><p><img src="/img/ZJU-VPN-connection-in-Linux/3.png"></p><ol start="2" type="1"><li>输入账号和密码后，就可以直接连接校园网了，连接命令如下。终端可能会显示retrying，这个属于正常现象，不是配置的问题。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zjunet vpn -c<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>连接成功如图4所示。</li></ol><p><img src="/img/ZJU-VPN-connection-in-Linux/4.png"></p><ol start="4" type="1"><li>如果想断开连接，可以输入如下命令，即可断开连接，断开连接后的提示如图5所示。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zjunet vpn -d<br></code></pre></td></tr></tbody></table></figure><p><img src="/img/ZJU-VPN-connection-in-Linux/5.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SOFTWARE" scheme="http://zijunwan.github.io/categories/SOFTWARE/"/>
    
    
    <category term="linux" scheme="http://zijunwan.github.io/tags/linux/"/>
    
    <category term="vpn" scheme="http://zijunwan.github.io/tags/vpn/"/>
    
  </entry>
  
</feed>
