<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>初学OpenGL</title>
    <link href="/2024/12/15/Software/Learn-OpenGL-1/"/>
    <url>/2024/12/15/Software/Learn-OpenGL-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​ 今天在公司开始了第一天的实习。首先就让学习ray casting算法。</p><p>关于ray casting算法的心得我会在学习透彻之后再写一篇文章分析。今天首先做的事情就是配置了OpenGL然后学习了OpenGL配合VS的一些基本使用。</p><p>先上代码吧</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// openGL_test_d.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stdafx.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"GL/glut.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"math.h"</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">GL_display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">const</span>  GLfloat pi = <span class="hljs-number">3.1415926f</span>;<br>    GLfloat a = <span class="hljs-built_in">cos</span>(<span class="hljs-number">54</span> * pi / <span class="hljs-number">180</span>);<br>    GLfloat b = <span class="hljs-built_in">sin</span>(<span class="hljs-number">54</span> * pi / <span class="hljs-number">180</span>);<br>    GLfloat c = <span class="hljs-built_in">cos</span>(<span class="hljs-number">18</span> * pi / <span class="hljs-number">180</span>);<br>    GLfloat d = <span class="hljs-built_in">sin</span>(<span class="hljs-number">18</span> * pi / <span class="hljs-number">180</span>);<br>    GLfloat pointA[<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>};<br>    GLfloat pointB[<span class="hljs-number">2</span>] = { -a, -b };<br>    GLfloat pointC[<span class="hljs-number">2</span>] = { c, d };<br>    GLfloat pointD[<span class="hljs-number">2</span>] = { -c, d };<br>    GLfloat pointE[<span class="hljs-number">2</span>] = { a, -b };<br>    <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);     <span class="hljs-comment">//用于清除当前的颜色缓冲</span><br><span class="hljs-built_in">glBegin</span>(GL_LINE_LOOP);   <span class="hljs-comment">//设置连线方式位闭曲线</span><br><span class="hljs-built_in">glVertex2fv</span>(pointA);<br><span class="hljs-built_in">glVertex2fv</span>(pointB);<br><span class="hljs-built_in">glVertex2fv</span>(pointC);<br><span class="hljs-built_in">glVertex2fv</span>(pointD);<br><span class="hljs-built_in">glVertex2fv</span>(pointE);<br><span class="hljs-built_in">glEnd</span>();<br><span class="hljs-built_in">glFlush</span>();           <span class="hljs-comment">//强制刷新缓冲区，让画图程序进行</span><br>}<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-built_in">glutInit</span>(&amp;argc, argv);    <span class="hljs-comment">//初始化</span><br><span class="hljs-built_in">glutInitDisplayMode</span>(GLUT_RGB | GLUT_SINGLE);   <span class="hljs-comment">//设置显示方式RGB单缓冲</span><br><span class="hljs-built_in">glutInitWindowPosition</span>(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);             <span class="hljs-comment">//设置窗口位置</span><br><span class="hljs-built_in">glutInitWindowSize</span>(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);                 <span class="hljs-comment">//设置窗口大小</span><br><span class="hljs-built_in">glutCreateWindow</span>(<span class="hljs-string">"这真的是我的第一个openGL程序啦！！！"</span>);   <span class="hljs-comment">//窗口名称</span><br><span class="hljs-built_in">glutDisplayFunc</span>(&amp;GL_display);               <span class="hljs-comment">//函数显示</span><br><span class="hljs-built_in">glutMainLoop</span>();                            <span class="hljs-comment">//用循环让画图程序一直进行</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br> <br></code></pre></td></tr></tbody></table></figure><p>关于OpenGL的配置网上有详细教程，就不再说明了。这段代码的功能就是画一个五角星，用函数GL_display画出，这里用GLfloat而不用float的原因是不同的编译器可能float的内存大小会是32位或64位，而GLfloat不会出现这样的问题。</p><p>画图时首先定义了一些点，然后glVertex2fv用来定义这些点，并按照顺序连接起来。</p><p>总的来说，用openGL进行基础的画图工作的步骤就是这样，画图函数中先清除缓冲，然后定义点的顺序。在主函数中先进行初始化，并设置好一系列的参数，如显示方式，窗口大小，窗口位置等等，然后调用函数进行图像的显示，最后用循环让图像显示程序一直进行下去。</p><p>下面是另一个基础的图像显示代码，显示了一个六角星，图像初始化过程与画图过程与以上大致相同</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// GL_test_e.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br> <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stdafx.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;GL/glut.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"math.h"</span></span><br> <br><span class="hljs-type">const</span> GLfloat pi = <span class="hljs-number">3.1415926f</span>;<br><span class="hljs-type">const</span> GLfloat a = <span class="hljs-built_in">cos</span>(pi / <span class="hljs-number">6</span>);<br><span class="hljs-type">const</span> GLfloat b = <span class="hljs-built_in">sin</span>(pi / <span class="hljs-number">6</span>);<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GL_display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>GLfloat pointA[<span class="hljs-number">2</span>] = { <span class="hljs-number">0</span>, <span class="hljs-number">1.0</span> };<br>GLfloat pointB[<span class="hljs-number">2</span>] = { a, b };<br>GLfloat pointC[<span class="hljs-number">2</span>] = { a, -b };<br>GLfloat pointD[<span class="hljs-number">2</span>] = { <span class="hljs-number">0</span>, <span class="hljs-number">-1.0</span> };<br>GLfloat pointE[<span class="hljs-number">2</span>] = { -a, -b };<br>GLfloat pointF[<span class="hljs-number">2</span>] = { -a, b };<br><span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br><span class="hljs-built_in">glBegin</span>(GL_LINE_LOOP);<br><span class="hljs-built_in">glVertex2fv</span>(pointA);<br><span class="hljs-built_in">glVertex2fv</span>(pointE);<br><span class="hljs-built_in">glVertex2fv</span>(pointC);<br><span class="hljs-built_in">glEnd</span>();<br><span class="hljs-built_in">glFlush</span>();<br><span class="hljs-built_in">glBegin</span>(GL_LINE_LOOP);<br><span class="hljs-built_in">glVertex2fv</span>(pointF);<br><span class="hljs-built_in">glVertex2fv</span>(pointD);<br><span class="hljs-built_in">glVertex2fv</span>(pointB);<br><span class="hljs-built_in">glEnd</span>();<br><span class="hljs-built_in">glFlush</span>();<br>}<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-built_in">glutInit</span>(&amp;argc, argv);<br><span class="hljs-built_in">glutInitDisplayMode</span>(GLUT_RGB | GLUT_SINGLE);<br><span class="hljs-built_in">glutInitWindowPosition</span>(<span class="hljs-number">500</span>, <span class="hljs-number">500</span>);<br><span class="hljs-built_in">glutInitWindowSize</span>(<span class="hljs-number">600</span>, <span class="hljs-number">600</span>);<br><span class="hljs-built_in">glutCreateWindow</span>(<span class="hljs-string">"六角星"</span>);<br><span class="hljs-built_in">glutDisplayFunc</span>(&amp;GL_display);<br><span class="hljs-built_in">glutMainLoop</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>DEVELOPMENT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10需要system权限才能修改的解决办法</title>
    <link href="/2024/12/15/Software/Sloving-change-permission-win10/"/>
    <url>/2024/12/15/Software/Sloving-change-permission-win10/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本文内容简介">本文内容简介</h1><p>今天重装了系统，一时没想清楚直接用360粉碎了windows.old文件夹。导致C盘中出现了一个以数字命名的文件夹。当我尝试去删除的时候，发现文件夹需要各种权限才能删除，有管理员权限，有system权限，还有trustedinstaller权限。这里统一给出解决方案。另外，重装系统后windows.old文件夹的删除方式应该是磁盘清理，而不是用其他的方式。</p><ol type="1"><li>首先打开文件夹属性，然后选择安全，然后选择编辑，给自己的账号对文件夹的完全控制权，这样就能删除文件夹中的内容了，但是文件夹中的子文件夹是不能删除的，所以还需要选择高级，然后更改所有者，在跳出来的弹窗中选择高级，然后选择立即查找，找到自己的账号，然后选中，让所有者是自己的账号。然后选择左下角的启用继承，并勾选下面的使用可从此对象继承的权限项目替换所有子对象的权限项目。这样只要给最上层的文件夹设置完全控制，就可以删除整个文件夹中的内容了。</li></ol><figure><img src="/img/Sloving-change-permission-win10/1.png" alt=""><figcaption>1</figcaption></figure><figure><img src="/img/Sloving-change-permission-win10/2.png" alt=""><figcaption>2</figcaption></figure><p>若是列表中没有自己的账号，可以添加一个，方法和修改所有者是一样的</p><figure><img src="/img/Sloving-change-permission-win10/3.png" alt=""><figcaption>3</figcaption></figure><figure><img src="/img/Sloving-change-permission-win10/4.png" alt=""><figcaption>4</figcaption></figure><figure><img src="/img/Sloving-change-permission-win10/5.png" alt=""><figcaption>5</figcaption></figure><figure><img src="/img/Sloving-change-permission-win10/6.png" alt=""><figcaption>6</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>SOFTWARE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FPGA和CY7C68013A的连接以及控制程序</title>
    <link href="/2024/12/15/Embedded/FPGA-CY7C68013/"/>
    <url>/2024/12/15/Embedded/FPGA-CY7C68013/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本文内容简介">本文内容简介</h1><p>毕业设计的题目是“基于USB2.0的FPGA和PC之间的通讯”。用的是Altera的FPGA，具体型号暂时不清楚，后续会更新。USB控制器用的是CY7C68013A。开发软件是Quartus II 9.0。连接上是将FPGA和CY7C68013A连接，然后CY7C68013A和PC端连接。我会开一个文件夹写关于这个题目的相关文章。这是第一篇。 总的来说，搭建这个系统，主要分成两个部分。本文主要是关于FPGA控制CY7C68013A程序中的写数据部分。</p><p><strong>1. FPGA控制CY7C68013A部分的代码（Verilog/Quartus II 9.0）</strong> <strong>2. USB固件程序开发（C/Keil 5.1）</strong></p><h1 id="cy7c68013a内部结构介绍">CY7C68013A内部结构介绍</h1><p>首先介绍USB控制器，这是整个系统中很重要的一个部分。CY7C68013A是CYPress公司的一款USB控制器，使用广泛，内部结构图如下：</p><figure><img src="/img/FPGA-CY7C68013/1.png" alt=""><figcaption>CY7C68013A结构图</figcaption></figure><p>CY7C68013A有三种工作模式，Ports模式，GPIF模式，Slave FIFO模式，介绍固件程序篇再详细介绍。本次搭建的系统使用的是Slave FIFO模式。</p><h1 id="fpga和cy7c68013a的连接">FPGA和CY7C68013A的连接</h1><p>连接部分如图所示： <img src="/img/FPGA-CY7C68013/2.png" alt="硬件连接部分"></p><p>IFCLK是时钟信号。FLAGA，FLAGB，FLAGC，FLAGD都是FIFO的输出状态（空还是满或者是半满）标志信号，本次设计中暂时设定只是用一个FIFO，代码中也没有指出用的是哪个FIFO和FLAG信号，属于简化了设计 - SLOE是仅输入输出使能 - SLRD是读数据使能 - SLWR是写数据使能</p><p>FIFOADR[1:0]是FIFO选择信号，本设计中只用一个FIFO，所以代码中没有这个参数的设置 PKTEND是将FIFO的数据打包并传输到端点的输入端，就是数据输入了一部分后用这个信号将数据打包然后一起传输 FD[15:0]是数据传输信号，本次设计中使用的数据总线只有8位，简化了设计</p><h1 id="异步写信号">异步写信号</h1><p>异步写状态机示意图如下： <img src="/img/FPGA-CY7C68013/3.png" alt="异步写状态机"></p><ul><li>IDLE：当写数据事件发生时，进入状态1</li><li>状态1：激活FIFOADR[1:0]，指向输入FIFO，然后进入状态2</li><li>状态2：如果FIFO状态是满，就在状态2等待，如果没有满，就进入状态3</li><li>状态3：驱动数据到数据总线，使能SLWR信号，持续一个时钟周期后进入状态4</li><li>状态4：如果还有数据需要传输，回到状态2循环，否则结束进入IDLE状态</li></ul><p>本次设计中不考虑FIFOADR[1:0]的激活，所以在写数据事件发生时，直接进入状态2，这样可以简化设计，便于早期写代码 # Verilog代码</p><p>FPGA控制代码用Verilog编写，编译软件是Quartus II 9.0，仿真软件为Quartus自带 代码如下所示：</p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// a test for USB FIFO write</span><br><span class="hljs-comment">//last edit:2017.02.27</span><br><span class="hljs-comment">//  signal explaination</span><br><span class="hljs-comment">//  CLK(posedge) :   the Clock Signal </span><br><span class="hljs-comment">//  RRESET(posedge): restart all signal and give them a number </span><br><span class="hljs-comment">//  FULL(high means not full): to judge whether the FIFO is FULL or not  </span><br><span class="hljs-comment">//  SLOE(high),SLRD(high),SLCS(low):  control signal</span><br><span class="hljs-comment">//  SLWR: the write permitted signal</span><br><span class="hljs-comment">//  SLWR_reg(high means not permitted): the reg type of SLWR</span><br><span class="hljs-comment">//  PKTEND(low means effective): pack data</span><br><span class="hljs-keyword">module</span> JellyBeam(CLK,SLWR,SLCS,DATA,PKTEND,FULL,SLOE,RESET,SLRD);<br><span class="hljs-keyword">input</span> CLK,RESET;<br><span class="hljs-keyword">input</span> FULL;<br><span class="hljs-keyword">output</span> SLCS,SLOE,SLRD,SLWR,PKTEND;<br><span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]DATA;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]DATA;<br><span class="hljs-keyword">reg</span> SLCS,SLOE,SLRD,SLWR,PKTEND;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">11</span>:<span class="hljs-number">0</span>]cnt;<br><span class="hljs-keyword">reg</span> SLWR_reg;<br><br><span class="hljs-comment">//creat cnt and PKTEND</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> RESET)<br><span class="hljs-keyword">begin</span> <br>  <span class="hljs-keyword">if</span> (RESET)<br>    <span class="hljs-keyword">begin</span> <br>      cnt&lt;=<span class="hljs-number">12'b0</span>;<br>      PKTEND&lt;=<span class="hljs-number">1'b1</span>;    <span class="hljs-comment">//it's effective when it's low</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span>(SLWR_reg==<span class="hljs-number">1'b0</span> &amp;&amp;FULL==<span class="hljs-number">1'b1</span> &amp;&amp; PKTEND==<span class="hljs-number">1'b1</span>)<br>        <span class="hljs-keyword">begin</span> <br>          cnt&lt;=cnt+<span class="hljs-number">1'b1</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">case</span>({cnt[<span class="hljs-number">11</span>],cnt[<span class="hljs-number">10</span>],cnt[<span class="hljs-number">9</span>]})              <br>    <span class="hljs-comment">//the high 3-bit are 3 types of size of data pack,applying to 3 types of PKTEND </span><br>      <span class="hljs-number">3'b010</span>: <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]==<span class="hljs-number">8'b00001000</span>)       <br>                <span class="hljs-keyword">begin</span>                          <br>                  PKTEND&lt;=<span class="hljs-number">1'b0</span>;<br>                  cnt[<span class="hljs-number">11</span>:<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">011000000000</span>;<br>                <span class="hljs-keyword">end</span><br>              <span class="hljs-keyword">else</span><br>                PKTEND&lt;=<span class="hljs-number">1'b1</span>;<br>      <span class="hljs-number">3'b100</span>: <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]==<span class="hljs-number">8'b00010000</span>)<br>                <span class="hljs-keyword">begin</span><br>                  PKTEND&lt;=<span class="hljs-number">1'b0</span>;<br>                  cnt[<span class="hljs-number">11</span>:<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">101000000000</span>;<br>                <span class="hljs-keyword">end</span><br>              <span class="hljs-keyword">else</span> <br>                PKTEND&lt;=<span class="hljs-number">1'b1</span>;<br>      <span class="hljs-number">3'b110</span>: <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]==<span class="hljs-number">8'b00011000</span>)<br>                <span class="hljs-keyword">begin</span> <br>                  PKTEND&lt;=<span class="hljs-number">1'b0</span>;<br>                  cnt[<span class="hljs-number">11</span>:<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">111000000000</span>;<br>                <span class="hljs-keyword">end</span><br>              <span class="hljs-keyword">else</span><br>                PKTEND&lt;=<span class="hljs-number">1'b1</span>;<br>    <span class="hljs-keyword">default</span>: PKTEND&lt;=<span class="hljs-number">1'b1</span>;<br>    <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">//maintain the control point</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> RESET)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(RESET)<br>    <span class="hljs-keyword">begin</span> <br>      SLWR_reg&lt;=<span class="hljs-number">1'b0</span>;      <span class="hljs-comment">//slwr should be effective when it's low</span><br>      SLOE&lt;=<span class="hljs-number">1'b1</span>;<br>      SLCS&lt;=<span class="hljs-number">1'b0</span>;          <span class="hljs-comment">// beginning of the process,better to be low at the beginning</span><br>      SLRD&lt;=<span class="hljs-number">1'b1</span>;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">begin</span> <br>      SLOE&lt;=<span class="hljs-number">1'b1</span>;<br>      SLCS&lt;=<span class="hljs-number">1'b0</span>;<br>      SLRD&lt;=<span class="hljs-number">1'b1</span>;<br>        <span class="hljs-keyword">if</span>(FULL)<br>          <span class="hljs-keyword">begin</span><br>            SLWR_reg&lt;=~SLWR_reg;<br>          <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">else</span><br>          <span class="hljs-keyword">begin</span><br>            SLWR_reg&lt;=<span class="hljs-number">1'b1</span>;<br>          <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">//write data</span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> RESET)<br><span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span>(RESET)<br>    <span class="hljs-keyword">begin</span><br>      DATA&lt;=<span class="hljs-number">8'b00000000</span>;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">begin</span> <br>      <span class="hljs-keyword">if</span>(SLWR_reg==<span class="hljs-number">1'b0</span> &amp;&amp; FULL==<span class="hljs-number">1'b1</span> &amp;&amp; PKTEND==<span class="hljs-number">1'b1</span>)<br>        <span class="hljs-keyword">begin</span> <br>          DATA&lt;=cnt[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">//creat SLWR </span><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> RESET)<br><span class="hljs-keyword">begin</span> <br>  <span class="hljs-keyword">if</span>(RESET)<br>    <span class="hljs-keyword">begin</span> <br>      SLWR&lt;=<span class="hljs-number">1'b1</span>;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">begin</span><br>      SLWR&lt;=SLWR_reg;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></tbody></table></figure><p>代码中各信号已经有了注释，在这里不再花大篇幅解释。最后仿真结果如下图：</p><figure><img src="/img/FPGA-CY7C68013/4.png" alt=""><figcaption>仿真结果</figcaption></figure><p>数据中给出的时钟频率为200MHz，FULL信号为随机给入，RESET信号在刚开始给出，后续全程为低电平，从图中可以看出，数据能正确地传输到DATA端口中，然后通过DATA端口输入到CY7C68013A中 # 总结</p><p>本文中只写了写入数据部分，而且只是一个初稿，里面很多地方进行了简化设计，后续会进行更新和改进</p>]]></content>
    
    
    <categories>
      
      <category>DEVELOPMENT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quartus ii 9.0软件的使用和win10不兼容解决方案</title>
    <link href="/2024/12/15/Embedded/QuartusII/"/>
    <url>/2024/12/15/Embedded/QuartusII/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本文内容简介">本文内容简介</h1><p>本文介绍关于quartus软件的编译和仿真的内容，以Verilog代码为例，不进行电路图绘制。也提供一种win10下仿真不兼容的解决方案</p><h1 id="quartus-ii-9.0使用教程">Quartus ii 9.0使用教程</h1><ul><li><p>首先打开quartus <img src="/img/QuartusII/1.png" alt="quartus软件首页"></p></li><li><p>新建工程文件：File-&gt;New Project Wizard <img src="/img/QuartusII/2.png" alt="新建工程文件"></p></li><li><p>出现弹窗，点击下一步会进入工程文件夹路径选择界面，根据自己需要进行设置 <img src="/img/QuartusII/3.png" alt="设置工程文件路径"></p></li><li><p>弹窗会提示是否添加设计文件，如果有需要可以添加，没有的话就直接下一步 <img src="/img/QuartusII/4.png" alt="添加设计文件"></p></li><li><p>选择自己的芯片类型 <img src="/img/QuartusII/5.png" alt="选择芯片类型"></p></li><li><p>选择设计，仿真和时序的工具，如果没有使用到额外的工具就直接下一步 <img src="/img/QuartusII/6.png" alt="选择设计工具"></p></li><li><p>核对信息是否正确 <img src="/img/QuartusII/7.png" alt="核对信息"></p></li><li><p>点击finish，选择File-&gt;New，选Verilog HDL File <img src="/img/QuartusII/8.png" alt="Verilog HDL File"></p></li><li><p>写Verilog，写完后进行编译 <img src="/img/QuartusII/9.png" alt="Verilog HDL"></p></li><li><p>点击Start Compilation，选择保存文件，然后选择Verilog HDL文件存放路径，下面的添加到现有工程文件要选上 <img src="/img/QuartusII/10.png" alt="保存文件"></p></li><li><p>编译成功后会有弹窗提示，暂时不管警告内容，可以看看flow summary <img src="/img/QuartusII/11.png" alt="编译"></p></li><li><p>新建Vector Waveform File <img src="/img/QuartusII/12.png" alt="Vector Waveform File"></p></li><li><p>在左边Name区域右键点击，选择Insert Node or Bus <img src="/img/QuartusII/13.png" alt="Name"></p></li><li><p>点击右边的Node Finder <img src="/img/QuartusII/14.png" alt="Node Finder"></p></li><li><p>点击右上角List，左边会出现需要仿真的信号，然后将Node Found中的信号选中，移动到右边的Selected Nodes <img src="/img/QuartusII/15.png" alt="Find Nodes"></p></li><li><p>点击OK，开始进行波形设置 <img src="/img/QuartusII/16.png" alt="Waveform Setting"></p></li><li><p>左边的工具栏中有各种各样的信号，时序，高电平，低电平，反转，计数，随机值等，可以自己慢慢尝试 <img src="/img/QuartusII/17.png" alt="Simulation"></p></li><li><p>点击Assignments-&gt;Settings <img src="/img/QuartusII/18.png" alt="Settings"></p></li><li><p>将Simulation mode设置为Functional <img src="/img/QuartusII/19.png" alt="Functional"></p></li><li><p>点击Processing-&gt;Generate Functional Simulation Netlist，生成功能仿真网表，会有弹窗提示保存波形文件，下面也有将文件添加至现有工程文件的选项，这个要选中 <img src="/img/QuartusII/20.png" alt="Netlist"></p></li><li><p>保存完成后会有弹窗提示，然后就可以开始仿真了 <img src="/img/QuartusII/21.png" alt="Start Simulation"></p></li></ul><h1 id="win10不兼容解决方案">win10不兼容解决方案</h1><p>这个时候如果是win10的话，会出现卡死，因为Quartus II 9.0版本较低不支持win10。解决办法就是找到Quartus的exe文件然后选择兼容win7，我的路径是D:，找到后右键-&gt;属性-&gt;兼容性-&gt;兼容win7，我还勾选了以管理员身份运行，供参考</p><figure><img src="/img/QuartusII/22.png" alt=""><figcaption>win10</figcaption></figure><p>这样选择后在仿真时还是会卡死，卡死的时候切回到桌面，可以点击右下角，也可以直接win键+D，然后再切回去，仿真就完成了 <img src="/img/QuartusII/23.png" alt="Simulation Result"></p><p>从图中可以看出，仿真结果与预期相同</p>]]></content>
    
    
    <categories>
      
      <category>DEVELOPMENT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WORLD Vocoder</title>
    <link href="/2022/01/25/SignalProcessing/WORLD-Vocoder/"/>
    <url>/2022/01/25/SignalProcessing/WORLD-Vocoder/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>WORLD是由Yamanashi大学的MORISE团队在2016年开发的一款语音合成软件[1]，可以用来合成高质量的语音信号。该软件的特点是计算量小，能实时合成语音信息，且合成声音质量高于传统的合成算法。</p><h2 id="method">Method</h2><p>WORLD的系统框架如图1所示，其合成主要包括以下几个步骤：</p><ul><li>计算基础频率F0，使用DIO算法</li><li>计算频谱的包络线， 使用CheapTrick算法</li><li>计算非周期信号参数Aperiodicity parameters，使用PLATINUM算法</li></ul><figure><img src="/img/WORLD-Vocoder/1.png" alt=""><figcaption>图1：WORLD声码器计算流程图</figcaption></figure><h3 id="f0计算">F0计算</h3><p>F0是指一段声音信号的基频，即一段周期信号变化的最小频率。人声信号的F0决定了一段声音的音调特征，即被试声带的振动频率。一般来讲，男声的F0会比女声的低。F0有多种估计方法，例如YIN[2]、SWIPE[3]等。本文使用的是DIO算法[4, 5]，相较于之前的算法，DIO的计算更快，质量也很高。</p><p>DIO的计算分为3步：首先，我们用不同截止频率的低通滤波器对信号滤波，如果滤波后只有单个频率，将其转换为正弦周期信号并计算其周期<span class="math inline">\(T_0\)</span>。这样就得到了多个周期；然后计算信号的峰峰值，过零点间距等4个值，如图2所示。对于每个周期信号，这4个值的平均值就作为其对F0的估计，然后这4个值的标准差作为F0计算可信度的量化指标。因为理论上对于F0，这4个值应该是相等的，即标准差为0；最后选择可信度最高的周期信号对应的F0作为最终的估计值。</p><figure><img src="/img/WORLD-Vocoder/2.png" alt=""><figcaption>图2：使用DIO算法计算F0</figcaption></figure><h3 id="频谱估计">频谱估计</h3><p>频谱估计中，会计算声音信号的倒频谱（Cepstrum）然后用线性预测编码（Linear Prediction Coding）进行估计。LPC的计算依赖于信号的时序特征，而频谱的估计需要尽量避免这种依赖。因此发展出了一些估计算法，例如STRAIGHT及其改进版。WORLD中使用的是CheapTrick算法[6, 7]，其主要计算如下：</p><ul><li>首先估计信号的功率谱，使用的是长度为<span class="math inline">\(3T_0\)</span>的汉宁窗</li></ul><p><span class="math display">\[\sum_{0}^{3T_0}(y(t)\omega(t))^2dt = 1.125 \sum_{0}^{T_0}y^2(t)dt\]</span></p><ul><li>然后对功率谱做平滑处理，用宽度为<span class="math inline">\(2\omega_0 / 3\)</span>的三角窗平滑，其中<span class="math inline">\(\omega_0 = 2\pi / T_0\)</span></li></ul><p><span class="math display">\[P_s(\omega) = \frac{3}{2\omega_0} \sum_{\omega_0/3}^{-\omega_0/3}P(\omega+\lambda)d\lambda\]</span></p><ul><li>最后计算倒频谱，用同态滤波来计算</li></ul><p><span class="math display">\[P_l(\omega) = exp(F(\frac{sin(\pi f_0 \tau)}{\pi f_0 \tau} * (q_0 + 2q_1 cos(\frac{2\pi \tau}{T_0})) p_s(\tau)))\]</span></p><p><span class="math display">\[p_s(\tau) = F^{-1}(log(P_s(\omega)))\]</span></p><h3 id="非周期信号参数估计">非周期信号参数估计</h3><p>WORLD用PLATINUM算法[8]来估计非周期参数（Aperiodic Parameter）。AP的计算在其他合成算法中也有使用，例如STRAIGHT、TANDEM-STRAIGHT等。PLATINUM算法计算如下：。</p><ul><li><p>首先对波形添加宽为<span class="math inline">\(2T_0\)</span>的窗，计算其频谱<span class="math inline">\(X(\omega)\)</span></p></li><li><p>然后用频谱除以最小相谱得到<span class="math inline">\(X_p(\omega)\)</span></p></li></ul><p><span class="math display">\[X_p(\omega) = \frac{X(\omega)}{S_m(\omega)}\]</span></p><ul><li>最小相谱的计算如下：</li></ul><p><span class="math display">\[S_m(\omega) = exp(F[c_m(\tau)])\]</span></p><p><span class="math display">\[c_m(\tau)=\left \{ \begin{align}  2c(\tau), \tau&gt;0\\  c(\tau), \tau=0\\  0, \tau&lt;0\end{align}\right.\]</span></p><ul><li>最后计算<span class="math inline">\(X_p(\omega)\)</span>的逆傅立叶变换，得到非周期参数<span class="math inline">\(x_p(t)\)</span></li></ul><p><span class="math display">\[x_p(t) = F^{-1}[X_p(\omega)]\]</span></p><h2 id="合成">合成</h2><p>计算得到F0，频谱和非周期信号后。通过频谱包络计算最小相位谱，然后与激励信号计算卷积，即可得到合成的语音信号，计算框架如图3所示</p><figure><img src="/img/WORLD-Vocoder/3.png" alt=""><figcaption>图3：使用WORLD合成语音的系统框架</figcaption></figure><h2 id="代码">代码</h2><p><a href="https://github.com/mmorise/World">WORLD</a>的代码是基于C++的。Github上也有其Python Wrapper库--<a href="https://github.com/JeremyCCHsu/Python-Wrapper-for-World-Vocoder">PyWorld</a>。其使用样例如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#获取音频的采样点数值以及采样率</span><br>x, fs = sf. read( <span class="hljs-string">'utterance/vaiueo2d.wav'</span>)<br><span class="hljs-comment">#使用DIO算法计算音频的基频F0</span><br>_f <span class="hljs-number">0</span>, t = pw.dio( x, fs, f0_floor= <span class="hljs-number">50.0</span>, f0_ceil= <span class="hljs-number">600.0</span>, channels_in_octave= <span class="hljs-number">2</span>, frame_period=args.frame_period, speed=args.speed)<br><span class="hljs-comment">#使用CheapTrick算法计算音频的频谱包络</span><br>_sp = pw.cheaptrick( x, _f <span class="hljs-number">0</span>, t, fs)<br><span class="hljs-comment">#计算aperiodic参数</span><br>_ap = pw.d4c( x, _f <span class="hljs-number">0</span>, t, fs)<br><span class="hljs-comment">#基于以上参数合成音频</span><br>_y = pw.synthesize(_f <span class="hljs-number">0</span>, _sp, _ap, fs, args.frame_period)<br><span class="hljs-comment">#写入音频文件</span><br>sf. write( <span class="hljs-string">'test/y_without_f0_refinement.wav'</span>, _y, fs)<br></code></pre></td></tr></tbody></table></figure><h2 id="references">References</h2><p>[1] Morise M, Yokomori F, Ozawa K. WORLD: a vocoder-based high-quality speech synthesis system for real-time applications[J]. IEICE TRANSACTIONS on Information and Systems, 2016, 99(7): 1877-1884.</p><p>[2] A. Cheveign´e and H. Kawahara, “Yin, a fundamental frequency estimator for speech and music,” J. Acoust. Soc. Am., vol.111, no.4, pp.1917–1930, 2002.</p><p>[3] A. Camacho and J.G. Harris, “A sawtooth waveform inspired pitch estimator for speech and music,” J. Acoust. Soc. Am., vol.124, no.3, pp.1638–1652, 2008.</p><p>[4] M. Morise, H. Kawahara, and H. Katayose, “Fast and reliable f0 estimation method based on the period extraction of vocal fold vibration of singing voice and speech,” in Proc. AES 35th International Conference, CD-ROM Proceedings, 2009.</p><p>[5] M. Morise, H. Kawahara, and T. Nishiura, “Rapid f0 estimation for high-snr speech based on fundamental component extraction,” IEICE Trans. Inf. &amp; Syst. (Japanese Edition), vol.J93-D, no.2, pp.109–117, 2010.</p><p>[6] M. Morise, “Cheaptrick, a spectral envelope estimator for high-quality speech synthesis,” Speech Communication, vol.67, pp.1–7, 2015.</p><p>[7] M. Morise, “Error evaluation of an f0-adaptive spectral envelope estimator in robustness against the additive noise and f0 error,” IEICE Trans. on Information Systems, vol.E98-D, no.7, pp.1405–1408, 2015.</p><p>[8] M. Morise, “Platinum: A method to extract excitation signals for voice synthesis system,” Acoust. Sci. &amp; Tech., vol.33, no.2, pp.123–125, 2012.</p><p>[9] <a href="https://www.sohu.com/a/219420730_723464">开源的语音合成系统WORLD介绍以及使用方法</a></p>]]></content>
    
    
    <categories>
      
      <category>SIGNAL PROCESSING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Audio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mel Frequency Cepstral Coefficients</title>
    <link href="/2022/01/18/SignalProcessing/Mel-Frequency-Cepstral-Coefficients/"/>
    <url>/2022/01/18/SignalProcessing/Mel-Frequency-Cepstral-Coefficients/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>在语音信号处理中，我们需要得到不同声音的不同特征表示。这样我们可以对声音进行区分。对于传统的信号处理，我们常用频域分布，功率谱，能量等特征来描述一个一维信号。语音信号也不例外，作为一种常用的一维信号，其处理仍旧会使用传统的方法。但是也有些许不同。于是，我们就需要用 MFCC，即梅尔倒频谱系数来计算语音信号的特征。 与传统的信号处理不同的是，语音信号的处理需要考虑到人耳听到声音的感觉和传统方式处理后的数据的对应关系。例如：人的耳蜗会根据声音的不同在不同的地方共振；也不会太区分两个很细微的频率，特别是高频的声音；而且，人类对于声音大小的感知不是线性的，所以我们会计算对数。</p><h2 id="method">Method</h2><p>MFCC的计算主要包括以下几个步骤：</p><ol type="1"><li>预加重(Pre-Emphasis)</li></ol><p><span class="math display">\[ y(t) = x(t) - \alpha x(t-1) \]</span></p><p>其中，<span class="math inline">\(y(t)\)</span>是预加重后的数据, <span class="math inline">\(x(t)\)</span>是原始信号, <span class="math inline">\(\alpha\)</span>是预加重系数，一般介于0.97-1之间。其目的主要是提升高频部分，使信号的频谱更加平坦。同时，也避免后面计算傅立叶变换时出现数值问题。比较预加重前后的音频信号，如图1所示。 <img src="/img/Mel-Frequency-Cepstral-Coefficients/1.png" alt="Fig-1: 预加重前后音频信号对比"></p><ol start="2" type="1"><li><p>分帧(Frame) 也就是分bin，需要将原始信号拼接起来形成帧。每一帧的时间长度一般是20ms-30ms左右。然后也会采取滑动窗的形式，避免帧和帧之间差距过大。目前常用处理方式是，控制帧的范围在20ms-30ms之间，每一帧的重叠部分在50%左右。分帧后的音频信号如图2所示。可以看出和预加重的信号基本一致。 <img src="/img/Mel-Frequency-Cepstral-Coefficients/2.png" alt="Fig-2: 分帧后的音频信号"></p></li><li><p>加窗 (Window) 对每一帧数据进行划窗处理，用增加数据之间的连续性。对于非周期信号，由于傅立叶变换只能计算有限长度的信号，如果不加滑动窗，会产生频域泄漏。所以，可以用窗函数对信号进行截断，来减少这种频域的泄漏问题。这里我们使用汉宁窗。 <span class="math display">\[ w(n) = (1-a) - a \times cos(\frac{2 \pi n}{N-1})\]</span> 其中，<span class="math inline">\(N\)</span>是汉宁窗的长度，<span class="math inline">\(a\)</span>是汉宁窗的系数，一般取0.46。 所以，加窗后的信号为： <span class="math display">\[s(n) = x(n) \times w(n)\]</span> 其中，<span class="math inline">\(s(n)\)</span>是加窗后的信号，<span class="math inline">\(x(n)\)</span>是原始信号。</p></li><li><p>傅立叶变换(FFT) 对信号进行FFT，计算当前信号的频谱特性。 <span class="math display">\[ X(k) = \sum_{n=0}^{N-1} x(n) \times e^{-2\pi i k / N}, 0 \leq k \leq N-1 \]</span> 其中，<span class="math inline">\(X(k)\)</span>是频谱，<span class="math inline">\(x(n)\)</span>是加窗后的语音信号，<span class="math inline">\(N\)</span>是FFT点数。上述音频信号的功率谱如图3所示: <img src="/img/Mel-Frequency-Cepstral-Coefficients/3.png" alt="Fig-3: 音频信号的功率谱"></p></li><li><p>三角带通滤波器 将计算后的频谱用三角滤波器滤波。这组三角滤波器是与Mel尺度匹配的。一般来讲滤波器的个数在40个。梅尔频谱会更加关注低频的信号，而对高频的信号用低分辨率的感知。Mel三角滤波器组如图4所示。 <img src="/img/Mel-Frequency-Cepstral-Coefficients/4.jpeg" alt="Fig-4: Mel三角滤波器组"> Mel频谱和真实频谱之间的换算关系如下: <span class="math display">\[ m = 2595 log_{10}(1+\frac{f}{700})\]</span> <span class="math display">\[ f = 700(10^{m/2595}-1)\]</span> 其中，<span class="math inline">\(m\)</span>是Mel频谱，<span class="math inline">\(f\)</span>是真实频谱。 三角滤波器组的频率响应可以如下表示： <span class="math display">\[ H_m(k) = \begin{cases} 0 &amp; {k\leq f(m-1)} \newline \frac{2(k-f(m-1))}{(f(m+1)-f(m-1))(f(m)-f(m-1))} &amp; {f(m-1) \leq k \leq f(m)} \newline \frac{2(f(m+1)-k)}{(f(m+1)-f(m-1))(f(m)-f(m-1))} &amp; {f(m) \leq k \leq f(m+1)} \newline 0 &amp; {k \geq f(m+1)} \end{cases}\]</span> 其中，<span class="math inline">\(H_m(k)\)</span>是三角滤波器组的频率响应。<span class="math inline">\(f(m)\)</span>表示第<span class="math inline">\(m\)</span>个三角滤波器的中心频率。</p></li><li><p>离散余弦变换(DCT) 将上述滤波器组的系数进行离散余弦变换： <span class="math display">\[ C(n) = \sum_{m=0}^{n-1}s(m)cos(\frac{\pi n(m-0.5)}{M}), n = 1, 2, ..., L \]</span> DCT在这里的主要作用，是去除滤波器组中系数的高度相关性，将滤波器组系数的能量聚集起来，去除那些能量小的系数。经过计算以后，得到的就是MFCC系数了。</p></li></ol><p>以上就是MFCC的计算过程。对于语音问题，我们一般在计算DCT得到MFCC后，会再用正弦函数进行处理 (sinusoidal liftering)。主要是来淡化高阶MFCC系数的影响。因为在语音识别时，更高频的信号大多数是噪声。最后，我们一般也会进行归一化处理。得到的结果如图5所示。 <img src="/img/Mel-Frequency-Cepstral-Coefficients/5.png" alt="Fig-5: Filter Bank 和 MFCC归一化后的结果"></p><h2 id="code">Code</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> soundfile <span class="hljs-keyword">as</span> sf<br><span class="hljs-keyword">from</span> scipy.fftpack <span class="hljs-keyword">import</span> dct<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># pre-emphasis</span><br>alpha = <span class="hljs-number">0.97</span><br>f = sf.SoundFile(<span class="hljs-string">'bjkjg.wav'</span>)<br>d, sr = f.read(), f.samplerate<br>pd = np.append(d[<span class="hljs-number">0</span>], d[<span class="hljs-number">1</span>:] - alpha * d[:-<span class="hljs-number">1</span>])<br><br><span class="hljs-comment"># framing</span><br>frame_size, frame_stride = <span class="hljs-number">0.025</span>, <span class="hljs-number">0.01</span><br>frame_length = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">round</span>(frame_size*sr))<br>frame_step = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">round</span>(frame_stride*sr)) <br>signal_length = <span class="hljs-built_in">len</span>(pd)<br>num_frames = <span class="hljs-built_in">int</span>(np.ceil(<span class="hljs-built_in">float</span>(np.<span class="hljs-built_in">abs</span>(signal_length-frame_length))/frame_step))<br><br>pad_signal_length = num_frames * frame_step + frame_length<br>pad_signal = np.append(pd, np.zeros((pad_signal_length - signal_length)))<br><br>indices = np.tile(np.arange(<span class="hljs-number">0</span>,frame_length),(num_frames,<span class="hljs-number">1</span>))+np.tile(np.arange(<span class="hljs-number">0</span>,num_frames*frame_step,frame_step), (frame_length, <span class="hljs-number">1</span>)).T<br>frames = pad_signal[np.mat(indices).astype(np.int32, copy=<span class="hljs-literal">False</span>)]<br><br><span class="hljs-comment"># windowing</span><br>frames *= np.hamming(frame_length)<br><br><span class="hljs-comment"># fft</span><br>NFFT = <span class="hljs-number">512</span><br>mag_frames = np.absolute(np.fft.rfft(frames, NFFT))  <span class="hljs-comment"># Magnitude of the FFT</span><br>pow_frames = (<span class="hljs-number">1.0</span> / NFFT) * (mag_frames ** <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># filter banks</span><br>nfilt=<span class="hljs-number">40</span><br>low_freq_mel = <span class="hljs-number">0</span><br>high_freq_mel = (<span class="hljs-number">2595</span> * np.log10(<span class="hljs-number">1</span> + (sr / <span class="hljs-number">2</span>) / <span class="hljs-number">700</span>))  <span class="hljs-comment"># Convert Hz to Mel</span><br>mel_points = np.linspace(low_freq_mel, high_freq_mel, nfilt + <span class="hljs-number">2</span>)  <span class="hljs-comment"># Equally spaced in Mel scale</span><br>hz_points = (<span class="hljs-number">700</span> * (<span class="hljs-number">10</span>**(mel_points / <span class="hljs-number">2595</span>) - <span class="hljs-number">1</span>))  <span class="hljs-comment"># Convert Mel to Hz</span><br><span class="hljs-built_in">bin</span> = np.floor((NFFT + <span class="hljs-number">1</span>) * hz_points / sr)<br><br>fbank = np.zeros((nfilt, <span class="hljs-built_in">int</span>(np.floor(NFFT / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>))))<br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, nfilt + <span class="hljs-number">1</span>):<br>    f_m_minus = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>[m - <span class="hljs-number">1</span>])   <span class="hljs-comment"># left</span><br>    f_m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>[m])             <span class="hljs-comment"># center</span><br>    f_m_plus = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">bin</span>[m + <span class="hljs-number">1</span>])    <span class="hljs-comment"># right</span><br><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(f_m_minus, f_m):<br>        fbank[m - <span class="hljs-number">1</span>, k] = (k - <span class="hljs-built_in">bin</span>[m - <span class="hljs-number">1</span>]) / (<span class="hljs-built_in">bin</span>[m] - <span class="hljs-built_in">bin</span>[m - <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(f_m, f_m_plus):<br>        fbank[m - <span class="hljs-number">1</span>, k] = (<span class="hljs-built_in">bin</span>[m + <span class="hljs-number">1</span>] - k) / (<span class="hljs-built_in">bin</span>[m + <span class="hljs-number">1</span>] - <span class="hljs-built_in">bin</span>[m])<br>filter_banks = np.dot(pow_frames, fbank.T)<br>filter_banks = np.where(filter_banks == <span class="hljs-number">0</span>, np.finfo(<span class="hljs-built_in">float</span>).eps, filter_banks)  <span class="hljs-comment"># Numerical Stability</span><br>filter_banks = <span class="hljs-number">20</span> * np.log10(filter_banks)  <span class="hljs-comment"># dB</span><br><br><span class="hljs-comment"># dct</span><br>num_ceps = <span class="hljs-number">24</span><br>mfcc = dct(filter_banks, <span class="hljs-built_in">type</span>=<span class="hljs-number">2</span>, axis=<span class="hljs-number">1</span>, norm=<span class="hljs-string">'ortho'</span>)[:, <span class="hljs-number">1</span> : (num_ceps + <span class="hljs-number">1</span>)]<br>(nframes, ncoeff) = mfcc.shape<br><br><span class="hljs-comment"># liftering</span><br>n = np.arange(ncoeff)<br>cep_lifter =<span class="hljs-number">22</span><br>lift = <span class="hljs-number">1</span> + (cep_lifter / <span class="hljs-number">2</span>) * np.sin(np.pi * n / cep_lifter)<br>mfcc *= lift<br><br><span class="hljs-comment"># normalize</span><br>filter_banks -= (np.mean(filter_banks, axis=<span class="hljs-number">0</span>) + <span class="hljs-number">1e-8</span>)<br>mfcc -= (np.mean(mfcc, axis=<span class="hljs-number">0</span>) + <span class="hljs-number">1e-8</span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="references">References</h2><ol type="1"><li><a href="https://haythamfayek.com/2016/04/21/speech-processing-for-machine-learning.html">Speech Processing for Machine Learning: Filter banks, Mel-Frequency Cepstral Coefficients (MFCCs) and What's In-Between</a></li><li><a href="https://blog.csdn.net/jojozhangju/article/details/18678861">语音特征参数MFCC提取过程详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/24318554">语音识别第4讲：语音特征参数MFCC</a></li><li><a href="https://zhuanlan.zhihu.com/p/85299446">详解离散余弦变换（DCT）</a></li><li>Mohamed A. Deep Neural Network Acoustic Models for ASR[D]. University of Toronto, 2014.</li><li>Muda L, Begam M, Elamvazuthi I. Voice recognition algorithms using mel frequency cepstral coefficient (MFCC) and dynamic time warping (DTW) techniques[J]. arXiv preprint arXiv:1003.4083, 2010.</li><li>Zheng F, Zhang G, Song Z. Comparison of different implementations of MFCC[J]. Journal of Computer science and Technology, 2001, 16(6): 582-589.</li></ol>]]></content>
    
    
    <categories>
      
      <category>SIGNAL PROCESSING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Audio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地打开远程tensorboard</title>
    <link href="/2022/01/13/Software/tensorboard-ssh/"/>
    <url>/2022/01/13/Software/tensorboard-ssh/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题">问题</h3><p>在实验过程中，代码一般运行在服务器，但是连接服务器的图形界面一般比较麻烦，大部分情况下还是ssh连接。所以我们需要能在本地查看服务器上的代码运行进度。</p><h3 id="解决办法">解决办法</h3><p>如何解决这个问题呢？我们在服务器上运行tensorboard，设置好对应的端口，然后用ssh将本地的端口映射到服务器上tensorboard的端口。然后在本地浏览器打开localhost的对应端口，就能查看tensorboard的进度了。整个过程其实是一个映射的过程。</p><h3 id="代码">代码</h3><ul><li>在服务器上运行tensorboard</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tensorboard --logdir=&lt;log path&gt; --port=&lt;server port&gt; --host=&lt;server ip&gt;<br></code></pre></td></tr></tbody></table></figure><p>其中log path是tensorboard的日志路径，server port是tensorboard的端口，注意不要和本地其他端口冲突。server ip是服务器的IP地址。</p><ul><li>在本地运行ssh连接服务器</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -L &lt;local port&gt;:&lt;server ip&gt;:6006 username@&lt;server ip&gt;<br></code></pre></td></tr></tbody></table></figure><p>其中local port是本地的映射端口，server ip是服务器的ip地址，username是ssh的用户名。</p><ul><li>在本地浏览器打开本地端口 打开浏览器，输入网址：localhost:<local port="">，就能查看tensorboard的进度了。</local></li></ul><h3 id="结果">结果</h3><figure><img src="/img/tensorboard_ssh/1.jpg" alt=""><figcaption>tensorboard in local</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>SOFTWARE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmux常用命令</title>
    <link href="/2022/01/07/Software/tmux-command/"/>
    <url>/2022/01/07/Software/tmux-command/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用ssh连接服务器时，如果本地长时间没有操作，ssh会断开连接。这样会带来很多麻烦。首先是需要重新输入密码再连接，当然如果服务器有public key，这个过程可以省略。然后是ssh断开前的终端会自动关闭，这样如果是在跑代码的话，程序就中断了。为了解决这个问题，可以使用tmux，一个终端的多窗口管理工具。 tmux的作用很简单，就是新建终端，这个终端会一直保持在后台，即是ssh连接断开，终端也会继续运行。所以也就避免了上述的第二个问题。对于第一个问题，tmux在网络正常的情况下，是一直连接的。并不会出现ssh这种长时间不操作就断开的情况。tmux的主要用法如下：</p><ul><li>创建终端，这一步要在服务器上进行，在哪儿进行就是在哪台机器上新建终端，所以一般都是在服务器</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux new -s &lt;name&gt;<br></code></pre></td></tr></tbody></table></figure><p>这里的name是终端的名字，如果不设置的话，直接输入tmux就可以了，那么终端的名字默认是0，1，2以此类推。但是后期查找起来会很麻烦，如果终端很多的话。所以还是建议写个名字</p><ul><li>连接到已有的tmux终端</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux attach -t &lt;name&gt;<br></code></pre></td></tr></tbody></table></figure><p>这里的name就是上面的name。如果没设置的话，就是0，1，2这些数字编号。如果忘记了终端的名字，那么可以用</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux ls<br></code></pre></td></tr></tbody></table></figure><p>上述命令可以查询已有的tmux终端名字</p><ul><li>分离终端，如果需要关闭某一个终端，可以使用这一命令。值得注意的是，此命令只会关闭终端显示，但是仍旧会在后台运行</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux detach<br>tmux detach -P -s &lt;session name&gt;<br></code></pre></td></tr></tbody></table></figure><p>这一命令可以带参数，可以不带参数。如果不带参数，在哪个tmux终端窗口运行就detach哪个；如果带参数"s“，可以指定要detach的窗口。如果带参数"P"，那么会断开对应窗口的ssh连接，但是终端还是在后台运行。</p><ul><li>切换终端</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux switch -t &lt;name&gt;<br></code></pre></td></tr></tbody></table></figure><p>将当前终端切换到另外一个终端</p><ul><li>退出终端</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tmux kill-session -t &lt;name&gt;<br></code></pre></td></tr></tbody></table></figure><p>这一命令会退出当前的终端，其中运行的任务也会自动终止</p>]]></content>
    
    
    <categories>
      
      <category>SOFTWARE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Conditional Generative Adversarial Nets</title>
    <link href="/2021/12/25/DeepLearning/Conditional-Generative-Adversarial-Nets/"/>
    <url>/2021/12/25/DeepLearning/Conditional-Generative-Adversarial-Nets/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>本文主要介绍GAN的一种改进形式，Conditional GAN。原始的GAN更多的关注于数据的生成，但是由于输入的随机性，所以GAN生成数据具有很强的随机性。数据生成很”自由“。对于目前的应用来说，我们更希望是生成的数据能是受控制的，是和输入有关的。于是就有了CGAN。</p><h2 id="methods">Methods</h2><p>CGAN的基本框架如图-1所示。主要的改进就是在生成器和判别器的输入中都加入了label。生成器中加入label，可以生成对应的数据，即生成的数据分布和label相关<span class="math inline">\(G(z|y)\)</span>。判别器中加入label，可以判断数据是否和label相关。这样经过CGAN的损失函数迭代，可以使得生成的数据越来越靠近label对应的数据分布。</p><figure><img src="/img/Conditional-Generative-Adversarial-Nets/1.jpg" alt=""><figcaption>图1: CGAN基本框架</figcaption></figure><p>CGAN的损失函数如下。其中，<span class="math inline">\(x\)</span>是真实数据，<span class="math inline">\(y\)</span>是label，<span class="math inline">\(z\)</span>是用于生成数据的噪声信号。</p><p><span class="math display">\[\underset{G}{min} \underset{D}{max} V(D, G) = E_{x \sim p_{data}(x)}[log(D(x|y))]+E_{z \sim p_{z}}[log(1-D(G(z|y)))]\]</span></p><h2 id="applications">Applications</h2><p>CGAN的应用很广泛，可以用来生成特定风格的图像，或者特定的文字等内容。例如在pix2pix中[2]，我们用CGAN根据图像轮廓去进行颜色填充，根据地图轮廓去生成真实图像等。根据黑夜的图像生成白天的图像等。图2展示了根据轮廓进行颜色填充。</p><figure><img src="/img/Conditional-Generative-Adversarial-Nets/2.jpg" alt=""><figcaption>图2: pix2pix生成图像</figcaption></figure><p>参考文献[2]总结了CGAN生成图像时的一些常用的技巧，例如loss function的定义，patchGAN的应用等。文章中提到了，现有的生成模型的损失函数主要集中于计算像素点直接的平均距离，这样很容易忽视局部的信息，导致生成图像模糊。所以文章的改进如下：</p><ul><li>在CGAN的损失函数中加入L1范数，关注全局的相似度；而CGAN本身的损失函数则关注于图像的轮廓等局部信息</li></ul><p>GAN的损失函数： <span class="math display">\[L_{GAN}(G, D) = \underset{G}{min}\underset{D}{max}E_y[log(D(y))]+E_{x, z}[log(1-D(G(x, z)))]\]</span></p><p>L1范数： <span class="math display">\[L_{L1}(G) = E_{(x,y,z)} ||(y - G(x, z))||^1 \]</span></p><p>损失函数： <span class="math display">\[G^* = L_{GAN}(G, D) + \lambda * L_{L1}(G)\]</span></p><ul><li>加入dropout，BatchNorm层</li><li>生成器的CNN网络使用U-Net结构，并采用skip连接</li><li>使用Markovian判别器(PatchGAN)，更加关注于图像局部信息</li></ul><h2 id="experiment">Experiment</h2><p>基于CGAN的原理，利用MNIST数据集，输入为图像的标签和噪声，生成图像，判断生成图像的标签和真实图像标签是否相同。原始图像如图3(a)所示，生成图像如图3(b)所示。可以看出，生成图像的数字和原始数据是相似的。</p><p>代码链接：<a href="https://github.com/FrankMartinem/Algorithm">CGAN代码</a></p><figure><img src="/img/Conditional-Generative-Adversarial-Nets/4.jpg" alt=""><figcaption>图3: (a) 原始图像；(b) 解码图像</figcaption></figure><h2 id="summary">Summary</h2><p>CGAN相较于GAN，加入了label，使得数据生成更加可控，生成的数据和label更加相关。</p><h2 id="references">References</h2><ol type="1"><li><p>Mirza M, Osindero S. Conditional generative adversarial nets[J]. arXiv preprint arXiv:1411.1784, 2014.</p></li><li><p>Isola P, Zhu J Y, Zhou T, et al. Image-to-image translation with conditional adversarial networks[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2017: 1125-1134.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>DEEP LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CGAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Generative Adversarial Nets</title>
    <link href="/2021/12/23/DeepLearning/Generative-Adversarial-Nets/"/>
    <url>/2021/12/23/DeepLearning/Generative-Adversarial-Nets/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>本文将介绍对抗生成网络（GAN）的基础框架，以及主要的推导过程。首先是GAN的基本概念：GAN的主要思想是博弈。利用生成器<span class="math inline">\(G\)</span>和判别器<span class="math inline">\(D\)</span>的博弈。来使得生成器能够准确生成出类似于原始数据分布的样本；同时在博弈过程中，使得判别器能更加准确的区分出原始数据和生成数据。</p><h2 id="method">Method</h2><p>假设有一组样本<span class="math inline">\(data\)</span>，其数据分布为<span class="math inline">\(p_{data}\)</span>。生成器<span class="math inline">\(G\)</span>根据一组噪声数据<span class="math inline">\(z\)</span>，其分布为<span class="math inline">\(p_z\)</span>，生成一组数据<span class="math inline">\(G(z)\)</span>，判别器为<span class="math inline">\(D\)</span>。其中生成器和判别器的参数分别为<span class="math inline">\(\theta_{g}\)</span>和<span class="math inline">\(\theta_{d}\)</span>。那么，生成器的目标是使得生成的数据<span class="math inline">\(G(z)\)</span>更接近真实数据分布<span class="math inline">\(p_{data}\)</span>，也就是说<span class="math inline">\(log[D(G(z))]\)</span>要尽可能大。然后对于判别器<span class="math inline">\(D\)</span>，其对于真实数据的判别要更准确，即<span class="math inline">\(log[D(x)]\)</span>要尽可能大。所以，根据上述问题可以构造以下条件：</p><p><span class="math display">\[\underset{G}{min} \underset{D}{max} E_{x \sim p_{data}(x)}[log(D(x))] + E_{z \sim p_{z}[log(1-D(G(z)))]}\]</span></p><p>Goodfellow的论文中给出了下面的图，可以解释GAN的迭代过程。蓝线是判别器输出的数据分布；绿线是生成器输出的数据分布；黑线是真实的数据分布；<span class="math inline">\(z\)</span>是噪声数据，通过生成器映射到数据<span class="math inline">\(x\)</span>。从而计算生成器输出的分布。在一开始，生成器<span class="math inline">\(G\)</span>的输出分布和真实的分布差距很大，判别器可以很轻易的区分生成数据和真实数据；但是也仅限于中间的部分，对于两者重合的部分，判别器的区分效果并不好；然后在(b)图中，对判别器参数进行迭代优化（后面会证明，判别器的参数存在最优解），使得判别器的输出结果更加稳定平滑也更加准确；(c)图中迭代了生成器的参数，使得生成的数据更接近真实数据。如此循环迭代后，最理想的状态即是达到(d)图，判别器无法区分生成数据和真实数据，生成数据的分布和真实数据相等。</p><figure><img src="/img/Generative-Adversarial-Nets/1.png" alt=""><figcaption>图-1: GAN的迭代过程</figcaption></figure><p>所以GAN的训练过程如图-2所示：</p><figure><img src="/img/Generative-Adversarial-Nets/2.jpg" alt=""><figcaption>图-2: GAN算法</figcaption></figure><p>GAN的上述迭代过程能找到使得<span class="math inline">\(G(z)\)</span>的分布<span class="math inline">\(p_g\)</span>更接近<span class="math inline">\(p_{data}\)</span>的最优解，必须满足以下条件：</p><ol type="1"><li>上述最优化问题有唯一解（全局最优解）<span class="math inline">\(G^{*}\)</span>，且该解满足<span class="math inline">\(p_g=p_{data}\)</span></li><li>上述最优化问题最终收敛（条件-1的必要条件）</li></ol><p>要证明上述条件成立，可以先证明在生成器<span class="math inline">\(G\)</span>固定时，判别器<span class="math inline">\(D\)</span>的参数具有最优解（根据算法-1的迭代过程来推导），证明如下所示。（主要是第二项，这里并不是换元转换，因为<span class="math inline">\(G\)</span>并不一定可逆，这里是基于Radon-Nikodym定理。具体证明方法这里不深究）。</p><p><span class="math display">\[V(G, D) = \int_{x}p_{data}(d)log(D(x))dx + \int_{z}p_z(z)log(1-D(G(z)))dz\]</span> <span class="math display">\[=\int_{x}p_{data}(d)log(D(x)) + p_{g}p_g(x)log(1-D(x)) dx\]</span></p><p>要使得<span class="math inline">\(V(G, D)\)</span>取得最大值，<span class="math inline">\(D(x)\)</span>就需要使函数<span class="math inline">\(f(D) = p_{data}log(D) + p_{g}log(1-D)\)</span>取最大值，根据拉格朗日中值定理，可以计算得到：取最大值的<span class="math inline">\(D(x)\)</span>应该满足<span class="math inline">\(D^{*}(x) = \frac{p_{data}}{p_{data}+p_{g}}\)</span>。所以，生成器<span class="math inline">\(G\)</span>固定时，判别器<span class="math inline">\(D\)</span>的参数具有最优解，该最优解满足<span class="math inline">\(D(x) = \frac{p_{data}}{p_{data}+p_{g}}\)</span></p><p>然后，需要证明当且仅当<span class="math inline">\(p_g=p_{data}\)</span>时，训练函数<span class="math inline">\(C(G) = \underset{D}{max}V(G, D)\)</span>取得全局最小值。证明如下： 当<span class="math inline">\(p_g=p_{data}\)</span>，根据上述推导可知<span class="math inline">\(D(x) = \frac{1}{2}\)</span>。带入到<span class="math inline">\(V(G, D)\)</span>中，可得：</p><p><span class="math display">\[V(G, D^*) = \int_{x}p_{data}(x)log(\frac{1}{2})+p_{g}(x)log(1-\frac{1}{2})dx\]</span> <span class="math display">\[ = -log(2)\int_{x}p_{data}(x)dx-log(2)\int_{x}p_{g}(x)dx\]</span> <span class="math display">\[ = -log(2) - log(2) = -log(4)\]</span></p><p>（概率的积分是1）所以当<span class="math inline">\(p_g=p_{data}\)</span>时，训练函数的值是<span class="math inline">\(-log(4)\)</span>，下面需要证明这是最小值，且只有<span class="math inline">\(p_g=p_{data}\)</span>时条件才成立。于是我们假设<span class="math inline">\(p_g \neq p_{data}\)</span>。但是判别器<span class="math inline">\(D\)</span>仍旧取得最优解。所以有：</p><p><span class="math display">\[V(G, D^*) = \int_{x}p_{data}(x)log(\frac{p_{data}}{p_{data}+p_{g}}) + p_{g}(x)log(\frac{p_{g}}{p_{data}+p_{g}})dx\]</span> <span class="math display">\[= \int_{x}(log(2)-log(2))p_{data}(x) + p_{data}(x)log(\frac{p_{data}}{p_{data}+p_{g}}) + \]</span> <span class="math display">\[ \int_{x}(log(2)-log(2))p_{g}(x) + p_{g}(x)log(\frac{p_{g}}{p_{data}+p_{g}})dx\]</span> <span class="math display">\[= -log(2)\int_{x}p_{g}(x)+p_{data}(x)dx + \int_{x}p_{data}(x)(log(2)+log(\frac{p_{data}}{p_{data}+p_{g}}))dx + \]</span> <span class="math display">\[ \int_{x}p_{g}(log(2) + log(\frac{p_{g}}{p_{data}+p_{g}})dx\]</span> <span class="math display">\[= -log(4) + \int_{x}p_{data}(x)log(\frac{p_{data}}{(p_{data}+p_{g})/2})) + \int_{x}p_{g}(x)log(\frac{p_{g}}{(p_{data}//2+p_{g})/2})\]</span></p><p>根据KL散度的定义，可以得到：</p><p><span class="math display">\[V(G, D^*) = -log(4) + KL(p_{data}|\frac{p_{data}+p_{g}}{2}) + KL(p_{g}|\frac{p_{data}+p_{g}}{2})\]</span></p><p>由于<span class="math inline">\(KL(p|q) \geq 0\)</span>，所以<span class="math inline">\(V(G, D)\)</span>当且仅当<span class="math inline">\(p_{data}=p_{g}\)</span>时取得最小值<span class="math inline">\(-log(4)\)</span>。 <span class="math inline">\(KL(p_{data}|\frac{p_{data}+p_{g}}{2}) + KL(p_{g}|\frac{p_{data}+p_{g}}{2}) = JSD(p_{data}|p_{g}\)</span>，论文中是根据Jensen–Shannon散度来计算的。结论是一致的。</p><p>最后是关于<span class="math inline">\(C(G) = V(G, D)\)</span>的收敛的证明。论文中的证明主要是根据导数的特性，以及分布<span class="math inline">\(p_{g}\)</span>属于凸函数的特点来证明的。</p><h2 id="experiment">Experiment</h2><p>基于GAN的原理，本文使用MNIST数据集进行实验。判断GAN是否能生成和MNIST数据集很像的图像。 <a href="https://github.com/FrankMartinem/Algorithm">代码链接</a>。原始的MNIST数据如图3(a)所示。生成的数据如图4所示。</p><p><img src="/img/Generative-Adversarial-Nets/3.jpg" alt="图3：MNIST原始数据"> <img src="/img/Generative-Adversarial-Nets/4.png" alt="图4：GAN生成的数据"></p><h2 id="summary">Summary</h2><p>以上就是最基础的GAN的概念以及推导过程。尽管已经证明了GAN的推导过程的可行性。但是在实际应用中，要使得GAN收敛并得到好的效果，还需要一些训练技巧。 - 首先是GAN的收敛问题，虽然已经证明GAN的迭代函数是收敛的，但是收敛的前提是生成器函数为凸函数。且由于神经网络迭代的特性。我们无法确定神经网络是通过何种策略调整，来达到纳什均衡的（也就是GAN有很好的表现的状态，论文中的观点）。 - 然后是<span class="math inline">\(p_{g}\)</span>没办法显示表示，因为是生成器的输出。然后是<span class="math inline">\(p_{data}\)</span>未知，虽然可以根据这一分布计算<span class="math inline">\(D\)</span>的最优解，但是并没有办法求出具体数值。</p><h2 id="references">References</h2><p>[1] Goodfellow et al., 2014. Generative Adversarial Nets.</p>]]></content>
    
    
    <categories>
      
      <category>DEEP LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/12/20/hello-world/"/>
    <url>/2021/12/20/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo new <span class="hljs-string">"My New Post"</span></span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo server</span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo generate</span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo deploy</span><br></code></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Bypy pack的使用</title>
    <link href="/2021/12/14/Software/Bypy-tutorial/"/>
    <url>/2021/12/14/Software/Bypy-tutorial/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景">背景</h2><p>网页上的一些资料，有一些是存储在百度网盘的。一些大文件下载时，需要安装百度网盘客户端。有时候在一些虚拟机，或者Linux服务器端没有GUI桌面的情况下，下载文件就会很不方便。而且很多时候我也不想安装百度网盘的客户端，感觉很难用。所以希望有一种能用命令行下载百度网盘文件的方式。</p><p>经过搜索后，发现了一个python的包Bypy，能在终端下载百度网盘的文件。这里记录一下Bypy的使用方式，方便以后查询。</p><h2 id="使用方法">使用方法</h2><ol type="1"><li><p>安装</p><p>安装方式跟普通的python包一样：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install bypy<br></code></pre></td></tr></tbody></table></figure><p>在离线状态下，可以在pypi官网下载bypy的whl文件，同样通过pip安装</p></li><li><p>初始化</p><p>初次使用时，需要授权bypy访问自己的百度网盘信息。Byby包并不能直接下载任意的百度网盘文件，需要先存储到自己的网盘的特定路径。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bypy info<br></code></pre></td></tr></tbody></table></figure><p>打开命令行弹出的网页，登录百度账号，然后复制授权码，等待bypy连接百度网盘。连接完成后，会显示百度网盘的已用空间和总空间。这里注意，可能会出现无响应或者连接失败的情况，这时使用pip卸载bypy再重新安装，也还是会用之前的授权码继续尝试连接，这时需要删除.bypy文件夹中的bypy.json文件，授权码时存储在这里的。</p></li><li><p>下载文件</p><p>bypy包只能读取百度网盘中apps/bypy/文件夹下的文件，所以将需要下载的文件移动到这个文件夹，然后再下载或者上传文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">bypy list  # 显示文件夹的中文件<br>bypy download [remote] [local path]  # 下载文件或者文件夹<br>bypy downfile &lt;remote file&gt; [local path]  # 下载文件<br>bypy downdir &lt;remote dir&gt; [local dir]  # 下载整个文件夹<br>bypy upload [local path] [remote path]  # 上传文件或文件夹（上传时百度网盘会检查文件校验，如果已经收录过，则秒传<br>bypy syncup [local path] [remote path]  # 同上<br></code></pre></td></tr></tbody></table></figure></li><li><p>下载加速</p><p>bypy默认的下载器，并不能达到最大下载速度。百度非会员下载已经很慢了，所以最好是换其他的下载器。bypy支持的第三方下载器只有aria2。我们可以安装aria2。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install aria2<br></code></pre></td></tr></tbody></table></figure><p>安装完aria2之后，在bypy的参数中设置使用的下载器，使用--downloader参数设置，--downloader-arguments可以设置下载器的参数，这里不细究了，用默认就可以</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">bypy <span class="hljs-attr">--downloader</span> aria2 download <span class="hljs-selector-attr">[remote]</span> <span class="hljs-selector-attr">[local path]</span> <br></code></pre></td></tr></tbody></table></figure><p>然后等文件下载就可以了。这里需要注意的是，由于文件一般都比较大，而且百度网盘下载的又慢，所以最好配合tmux一起使用，防止下载过程突然中断。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>DEVELOPMENT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器非管理员配置python环境</title>
    <link href="/2021/12/14/Software/Config-Python-for-Unroot-Users/"/>
    <url>/2021/12/14/Software/Config-Python-for-Unroot-Users/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>Linux服务器配置python环境时，默认的安装位置是"/usr/bin"。但没有管理员权限时是无法写文件到当前路径的。而且多人共用一个服务器时，大家的python环境各不相同，每个人也会配置自己的python环境。所以在home文件夹安装配置自己的python环境是更合适的。一下是在没有root权限的情况下配置python的方法。</p><h2 id="method">Method</h2><ol type="1"><li>下载python source code到home/your name 文件夹。这里以python-3.10.1为例，可以从<a href="https://www.python.org/downloads/source/">python官网</a>下载对应版本的源代码</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://www.python.org/ftp/python/3.10.1/Python-3.10.1.tgz<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>解压文件</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd download dir<br>tar -xzvf Python-3.10.1.tgz<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li><p>下载好以后，如果直接安装，会有以下的问题：首先是openssl，用于软件的安全通信，避免被窃听的一个toolkit。一般是系统级的app；然后是zlib，这个组件用于数据压缩和解压，如果需要使用科学计算的库，那么zlib是必须的；最后是libffi，相当于C的编译器，同样也是用于科学计算。上述组件均可以通过管理员sudo，yum安装。但是如果没有管理员权限，那么需要自行安装。</p></li><li><p>安装openssl</p></li></ol><p>下载并解压<a href="https://www.openssl.org/source/">openssl</a></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://www.openssl.org/source/openssl-3.0.0.tar.gz<br>tar -xzvf openssl-3.0.0.tar.gz<br></code></pre></td></tr></tbody></table></figure><p>编译并安装</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd openssl-3.0.0.tar.gz<br>./config --prefix=/home/your name/openssl_dir<br>make -j48 <br>make install<br></code></pre></td></tr></tbody></table></figure><ol start="5" type="1"><li>安装<a href="http://www.zlib.net/">zlib</a></li></ol><p>下载，解压，编译并安装</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://www.zlib.net/zlib-1.2.11.tar.gz<br>tar -xzvf zlib-1.2.11.tar.gz<br>cd zlib-1.2.11.tar.gz<br>./configure --prefix=/home/your name/zlib_dir<br>make -j48<br>make install<br></code></pre></td></tr></tbody></table></figure><ol start="6" type="1"><li>安装<a href="https://github.com/libffi/libffi/releases">libffi</a></li></ol><p>下载，解压，编译并安装</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/libffi/libffi/releases/download/v3.4.2/libffi-3.4.2.tar.gz<br>tar -xzvf libffi-3.4.2.tar.gz<br>cd libffi-3.4.2.tar.gz<br>./configure --prefix=/home/your name/libffi<br>make -j48<br>make install<br></code></pre></td></tr></tbody></table></figure><ol start="7" type="1"><li>将上述安装文件的路径写入环境变量</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/your name/libffi_dir/lib/pkgconfig<br>export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/home/your_name/openssl_dir/lib:/home/your name/zlib_dir/lib:/home/your_name/libffi_dir/lib<br>export PKG_CONFIG_PATH=/home/jacob/libffi/lib/pkgconfig<br>export CFLAGS=-I/home/your name/libffi_dir/include<br>export LDFLAGS=-L/home/your name/libffi_dir/lib<br></code></pre></td></tr></tbody></table></figure><ol start="8" type="1"><li>进入python的setup文件，修改部分编译信息</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd python_path/Modules/<br>vim Setup.dist<br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消下面的注释</span><br>SSL=/home/your name/openssl_dir<br>_ssl _ssl.c -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl -L$(SSL)/lib -lssl -lcrypto<br>zlib zlibmodule.c -I/home/your name/zlib_dir/include -L/home/your name/zlib_dir/lib -lz<br></code></pre></td></tr></tbody></table></figure><ol start="9" type="1"><li>编译python代码，这里需要gcc编译器，一般Linux发行版都自带gcc编译器，如果没有安装，请联系管理员。同时，编译过程需要配置特定的参数</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd Python-3.10.1<br>./configure LDFLAGS="-L/home/your name/libffi_dir/lib64 -Wl,--rpath=/home/your name/libffi_dir/lib64" CFLAGS="-I/home/your name/libffi_dir/include" PKG_CONFIG_PATH="${libffi}/lib/pkgconfig" --prefix=/home/your name/your path --with-openssl=/home/your name/openssl_dir<br>make # make -j48 这里不推荐，因为会编译所有的test file，耗时较长，机器快的话也要20min-30min左右<br>make install<br></code></pre></td></tr></tbody></table></figure><h2 id="summary">Summary</h2><p>以上就是非管理员账户在home文件夹安装自己的python环境的方法。这种方法能安装简易的python环境，但是如果需要很复杂的计算，例如scikt，pytorch，tensorflow等强烈依赖底层C链接库的模块，那么上述方法或许可行。因为整个过程无非是把库文件的源代码安装到了home文件夹里，然后修改环境变量配置。但是如果真的是很复杂的编译和依赖，不建议使用上述方法。上述方法主要参考以下博客和文章：</p><ol type="1"><li><a href="https://blog.csdn.net/u012440550/article/details/109371016">CSDN</a></li><li><a href="https://stackoverflow.com/questions/65691539/locally-compiled-libffi-files-not-getting-picked-up-while-recompiling-python-3-p">Stackoverflow</a></li><li><a href="https://hellovimo.github.io/uvm_testbench_gen/localpythoninstall.html">Github Pages</a></li></ol><p>那么，针对Introduction提出的问题，每个人都需要自定义自己的python环境，是否有更好的解决方法呢。答案是<strong>有的</strong>，那就是由管理员安装python到usr目录。然后每个人可以在home文件夹新建自己的虚拟环境。只需要使用pip3命令即可：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 -m pip install --user virtualenv<br>python3 -m venv /home/your name/python_dir<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>SOFTWARE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极大似然估计 - Log Likelihood</title>
    <link href="/2021/12/05/MachineLearning/Log-Likelihood/"/>
    <url>/2021/12/05/MachineLearning/Log-Likelihood/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="introduction">Introduction</h2><p>极大似然估计是传统机器学习以及深度学习中都常用的计算方法。其主要的目的，是根据现有的数据分布，估计采样得到现有数据的更大的数据集的分布。</p><h2 id="method">Method</h2><h3 id="定义">定义</h3><p>假设从一个很大的数据集中采集到有<span class="math inline">\(m\)</span>个数据的数据集<span class="math inline">\(X=\{x_1,...,x_m\}\)</span>。所以原始的很大的数据集的分布为<span class="math inline">\(P_{data}(x)\)</span>。根据数据计算得到的分布为<span class="math inline">\(P_{model}(x; \theta)\)</span>。其中<span class="math inline">\(\theta\)</span>是模型的参数。所以：</p><p><span class="math display">\[\theta= \underset{\theta}{\operatorname{arg max}}P_{model}(x;\theta)\]</span></p><p><span class="math display">\[\theta= \underset{\theta}{\operatorname{arg max}}\prod_{i=1}^{m}P_{model}(x_i;\theta)\]</span></p><p>这里直接计算概率连乘很不方便，而且容易出现极小值。由于log函数的单调性，且能处理连乘问题，所以这里取对数。</p><p><span class="math display">\[\theta = \underset{\theta}{\operatorname{arg max}}\sum_{i=1}^{m}log(P_{model}(x_i; \theta))\]</span></p><p>求和符号的计算仍旧存在些许不方便，所以这里缩放<span class="math inline">\(m\)</span>倍，且数据从当前数据集中提取，当前数据集的经验分布设为<span class="math inline">\(\hat{P_{data}}\)</span>。 所以： <span class="math display">\[\theta=\underset{\theta}{\operatorname{arg max}} E_{x \sim \hat{P_{data}}}(P_{model}(x;\theta))\]</span></p><p>以上就是极大似然函数。</p><h3 id="kl散度视角">KL散度视角</h3><p>根据问题的描述，我们需要求解数据的分布<span class="math inline">\(P_{model}(x; \theta)\)</span>，使得其最接近数据集的分布<span class="math inline">\(\hat{P_{data}}(x)\)</span>。从KL散度出发，即需要最小化两者的KL散度（注意：KL散度计算是有顺序的，即<span class="math inline">\(D_{KL}(P||Q) \neq D_{KL}(Q||P)\)</span>。 KL散度计算如下：</p><p><span class="math display">\[D_{KL}(P_{data}(x)|| P_{model}(x; \theta))=E_{x\sim\hat P_{data}}[log(\hat P_{data}(x)) - log(P_{model}(x; \theta))]\]</span></p><p>第一项和模型参数无关，所以计算时只需要最小化第二项，即： <span class="math display">\[\theta = \underset{\theta}{\operatorname{arg max}} -log(P_{model}(x; \theta))\]</span></p><p>这一步骤和定义中的最大化是相同的。</p>]]></content>
    
    
    <categories>
      
      <category>MACHINE LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>probability</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于SVD算法的无迹卡尔曼滤波</title>
    <link href="/2021/09/24/MachineLearning/SVD-UKF/"/>
    <url>/2021/09/24/MachineLearning/SVD-UKF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题">问题</h2><p>无迹卡尔曼滤波（Unscented Kalman Filter）是卡尔曼滤波（Kalman Filter）的改进版，其中取消了卡尔曼滤波中对于观测变量的一阶线性隐马尔可夫链的约束，也取消了观测变量和测量变量之间的线性关系。取而代之的是任意的函数，然后用无迹变换（Unscented Transform）来估计观测变量变化时以及观测变量和测量变量变化时的概率分布变化。但是，无迹卡尔曼滤波在计算时需要计算协方差矩阵的Cholesky分解，这一步需要保证协方差矩阵是正定矩阵。在真实计算中，由于观测变量可能有多维，且互相之间可能互相独立，导致协方差矩阵不一定是正定矩阵。也有可能由于参数的选择不当，导致协方差矩阵不满足正定矩阵的要求。从而导致计算无法进行。这也是无迹卡尔曼滤波中需要注意的地方。</p><h2 id="解决方法">解决方法</h2><p>对于协方差矩阵非正定的问题，目前有两种解决办法。一种是选择合适的参数。但是这种方法比较依赖经验，需要多次测试调整。第二种方法就是基于SVD的无迹卡尔曼滤波。这种方法利用奇异值分解（SVD）方法，将协方差矩阵分解为对角矩阵和另外两个矩阵。由于协方差矩阵中，对角线上的值一定是正的，因为对角线上的值就是不同维度的观测变量的方差。所以对角矩阵的值肯定是正的，所以可以开根号。协方差矩阵分解的计算方法如下：</p><p><span class="math display">\[[S, V, D] = SVD(P)\]</span> <span class="math display">\[P_{est} = S * \sqrt{V}\]</span></p><p>用上述步骤，替换无迹卡尔曼滤波计算中的Cholesky分解，即得到基于SVD的无迹卡尔曼滤波。因为协方差矩阵是对称的，所以<span class="math inline">\(S\)</span>的转置矩阵是<span class="math inline">\(D\)</span>，计算时只考虑一边即可。其余的计算步骤参考Unscented Kalman Filter。</p><h2 id="参考文献">参考文献</h2><ol type="1"><li>An Improved Unscented Kalman Filter Algorithm for Radar Azimuth Mutation</li></ol>]]></content>
    
    
    <categories>
      
      <category>MACHINE LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SVD-UKF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH Download and Upload</title>
    <link href="/2021/08/13/Software/SSH-Download-and-Upload/"/>
    <url>/2021/08/13/Software/SSH-Download-and-Upload/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ssh-从服务器下载文件或者上传文件以及文件夹">SSH 从服务器下载文件或者上传文件以及文件夹</h1><ol type="1"><li>从服务器下载文件</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp yourname@IP address:/path to your file/ /local path/<br>scp frank@10.212.48.177:~/Downloads/test.py ~/Downloads<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>从服务器下载文件夹</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r yourname@IP address:/path to your folder/ /local path/<br>scp -r frank@10.212.48.177:~/Downloads/test ~/Downloads<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>上传文件到服务器</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /path to your file/ yourname@IP address:/remote path/<br>scp ~/Downloads/test.py frank@10.212.48.177:~/Downloads<br></code></pre></td></tr></tbody></table></figure><ol start="4" type="1"><li>上传文件夹到服务器</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp -r /path to your folder/ yourname@IP address:/remote path/<br>scp -r ~/Downloads/test frank@10.212.48.177:~/Downloads<br></code></pre></td></tr></tbody></table></figure><p>注意，服务器的IP地址后的冒号和文件地址，文件夹地址之间没有空格</p>]]></content>
    
    
    <categories>
      
      <category>DEVELOPMENT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git下载仓库的单个文件</title>
    <link href="/2021/08/12/Software/Git-Clone-Part-of-Repository/"/>
    <url>/2021/08/12/Software/Git-Clone-Part-of-Repository/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述">问题描述</h2><p>如果一个仓库的文件很多，但是又只需要其中的一部分，这时下载全部的文件会很浪费时间，毕竟github的下载速度也慢。所以就需要想办法只下载部分文件。下面介绍三种方法。</p><h2 id="git指令下载">git指令下载</h2><p>git目前已经支持通过修改配置文件来下载单个文件，这里以我自己的仓库为例，项目仓库结构如图所示。我需要下载Algorithm项目下的Kalman整个文件夹，以及Wiener-Filter文件夹下的wienerfilter.py文件。那么可以通过如下方法实现。</p><figure><img src="/img/Git-Clone-Part-of-Repository/1.png" alt=""><figcaption>项目截图</figcaption></figure><ol type="1"><li>首先新建一个文件夹，然后clone整个仓库的结构以及git的改动文件。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir file<br>cd file<br>git init<br>git remote add -f origin &lt;url of target repository&gt;<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>然后配置git config文件，将sparsecheckout设置为true，即允许从仓库中下载部分的文件</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config core.sparseCheckout true<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>将你需要下载的文件添加到config文件中，对于例子中的要求，配置如下</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo "Kalman" &gt;&gt; .git/info/sparse-checkout<br>echo "Wiener-Filter/wienerfilter.py" &gt;&gt; .git/info/sparse-checkout<br></code></pre></td></tr></tbody></table></figure><ol start="4" type="1"><li>然后直接拉取项目，然后会根据配置文件拉取对应的文件</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull origin master<br></code></pre></td></tr></tbody></table></figure><p>命令行截图如图所示</p><figure><img src="/img/Git-Clone-Part-of-Repository/2.png" alt=""><figcaption>命令行截图</figcaption></figure><p>可以看出，最终只下载了需要的代码。详细的git sparse checkout的配置可以查询git官方文档[link]</p><h2 id="网页工具">网页工具</h2><p>可以通过<a href="https://minhaskamal.github.io/DownGit/#/home">这个网站</a>下载某个项目的部分文件，只需要把对应文件或文件夹的链接复制到下载框中即可。注意这里用的是网页链接，而不是仓库的url</p><figure><img src="/img/Git-Clone-Part-of-Repository/3.png" alt=""><figcaption>网页截图</figcaption></figure><h2 id="用svn配置只下载部分文件">用SVN配置只下载部分文件</h2><p>找到对应的文件夹，然后修改链接中的/tree/master/为/trunk/。例如例子中的Kalman文件夹链接为 https://github.com/FrankMartinem/Algorithm/tree/master/Kalman</p><p>修改为</p><p>https://github.com/FrankMartinem/Algorithm/trunks/Kalman</p><p>然后运行svn checkout命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">svn checkout https://github.com/FrankMartinem/Algorithm/trunk/Kalman<br></code></pre></td></tr></tbody></table></figure><p>然后就可以下载对应文件夹的文件了。如果下载的文件夹不在master分支上，那么需要找到对应的分支，然后修改为/branches/branchname/。例如在develop分支上，则修改为/branches/develop/。</p><h2 id="总结">总结</h2><p>以上就是三种下载单个文件的方法，笔者尝试了前两种方法，均能实现需求。由于笔者没有装svn，所以没有尝试svn方法，但是有很多人也尝试过这种方法，应该是可行的。</p><p>总体来看，三种方法各有优劣，git checkout方法配置麻烦，但是能同时下载多个不同位置的文件或者文件夹，只需要写好配置文件。但是如果项目文件很复杂，层级很多，而且git记录很多的话，那么第一步初始化就要花很长的时间。 网页版的话更方便快捷，但是对于复杂的需求，可能需要复制很多次网页链接然后下载很多次，会比较麻烦。而且这种方法依赖于浏览器和图形界面。</p><p>svn方法可能和网页版的缺点类似，也是只能针对单一文件夹设置。当然也可能svn还有其他的功能，这里不过多赘述。</p>]]></content>
    
    
    <categories>
      
      <category>DEVELOPMENT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下解压window中的zip文件的乱码问题</title>
    <link href="/2021/07/29/Software/Linux-unzip-file-from-Windows/"/>
    <url>/2021/07/29/Software/Linux-unzip-file-from-Windows/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在windows系统下压缩的zip文件，使用的编码格式是gbk，而Linux默认是utf-8的，所以解码后如果有中文，会出现乱码。解决方法就是利用unzip命令解压。然后设置好编码参数，解压命令如下。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip -O cp936 file-name.zip<br></code></pre></td></tr></tbody></table></figure><p>解压文件会显示在当前目录下，如果想解压到指定文件夹，可以自行修改参数。</p>]]></content>
    
    
    <categories>
      
      <category>SOFTWARE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex+Vscode Configuration in Ubuntu</title>
    <link href="/2021/07/28/Software/Latex-Vscode-Configuration-in-Ubuntu/"/>
    <url>/2021/07/28/Software/Latex-Vscode-Configuration-in-Ubuntu/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ubuntu下latex安装以及vscode配置">Ubuntu下Latex安装以及vscode配置</h1><p>本文主要介绍Ubuntu系统下Latex环境的配置，使用的软件有 - TexLive2021 - vscode</p><h2 id="安装texlive">安装TexLive</h2><ol type="1"><li><p>下载TexLive安装包，下载地址为：[TexLive][https://www.tug.org/texlive/acquire-netinstall.html]。官网下载可能会比较慢，可以选择国内镜像网站：[TexLive Tsinghua Mirror][https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/]。</p></li><li><p>解压对应的iso文件，Ubuntu18.04可以直接右键解压。也可以用mount命令挂载iso文件然后提取文件，这样会比较麻烦，这里也不多赘述。解压完后，文件内容如图1所示。 <img src="/img/Latex-Vscode-Configuration-in-Ubuntu/1.png"></p></li><li><p>cd到对应的文件目录，然后运行如下命令，可以在命令行中安装，如图2所示。根据提示，配置好需要安装的组件，然后回车安装即可。</p></li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ./install-tl<br></code></pre></td></tr></tbody></table></figure><p><img src="/img/Latex-Vscode-Configuration-in-Ubuntu/2.png"></p><ol start="4" type="1"><li>也可以用图形界面安装。先cd到对应文件目录，然后运行如下命令，就会显示和windows类似的图形界面了，如图3所示。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ./install-tl -gui -repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/<br></code></pre></td></tr></tbody></table></figure><p><img src="/img/Latex-Vscode-Configuration-in-Ubuntu/3.png"></p><p>建议对于大多数用户，安装完整版的TexLive，省得以后发现缺少依赖不能编译，会很麻烦。TexLive的安装较慢，耐心等待。安装完成后，在terminal中输入xelatex，latexmk等命令，如果显示command not found。那么需要添加TexLive到环境变量，添加的方法如下。如果显示有当前命令，那么直接到vscode配置部分。</p><h2 id="添加环境变量">添加环境变量</h2><p>找到对应的终端配置文件，如果是zsh则是.zshrc，如果是bash则是.bashrc。都在用户目录下。打开终端，输入如下命令。如果是其他shell则改成其他shell的配置文件，用不习惯vim可以用gedit。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim ~/.zshrc<br></code></pre></td></tr></tbody></table></figure><p>在配置文件中加入如下内容：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH="$PATH:/usr/local/texlive/2021/bin/x86_64-linux/"<br>export MANPATH="$MANPATH:/usr/local/texlive/2018/texmf-dist/doc/man"<br>export INFOPATH="$INFOPATH/usr/local/texlive/2018/texmf-dist/doc/info"<br></code></pre></td></tr></tbody></table></figure><p>配置环境变量需要注意的内容，可以参考另外一篇 [blog][https://frankmartinem.github.io/2021/06/01/Linux-Environment-Variable/]</p><p>配置完成后，打开终端输入xelatex，latexmk等命令，检查环境变量是否配置成功。</p><h2 id="vscode配置">vscode配置</h2><p>TexLive安装完成后，vscode的配置就比较简单了。主要包括以下步骤。 1. 安装Latex Workshop插件，在vscode的扩展商店里，直接搜索就能找到。</p><ol start="2" type="1"><li>配置Latex编译的json文件。安装好插件以后，需要配置好编译的一些参数，这里提供我自己的配置文件</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs shell">"latex-workshop.latex.tools":<br>[<br>    {<br>    "name": "latexmk",<br>    "command": "latexmk",<br>    "args": [<br>        "-synctex=1",<br>        "-interaction=nonstopmode",<br>        "-file-line-error",<br>        "-pdf",<br>        "%DOC%"<br>    ]<br>    },<br>    {<br>    "name": "xelatex",<br>    "command": "xelatex",<br>    "args": [<br>        "-synctex=1",<br>        "-interaction=nonstopmode",<br>        "-file-line-error",<br>        "%DOC%"<br>    ]<br>    },<br>    {<br>    "name": "pdflatex",<br>    "command": "pdflatex",<br>    "args": [<br>        "-synctex=1",<br>        "-interaction=nonstopmode",<br>        "-file-line-error",<br>        "%DOC%"<br>    ]<br>    },<br>    {<br>    "name": "bibtex",<br>    "command": "bibtex",<br>    "args": [<br>        "%DOCFILE%"<br>    ]<br>    }<br>],<br><br>"latex-workshop.latex.recipes":<br>[<br>    {<br>    "name": "latexmk",<br>    "tools": [<br>        "latexmk"<br>    ]<br>    },<br>    {<br>    "name": "xelatex -&gt; bibtex -&gt; xelatex*2",<br>    "tools": [<br>        "xelatex",<br>        "bibtex",<br>        "xelatex",<br>        "xelatex"<br>    ]<br>    },<br>    {<br>    "name": "xelatex",<br>    "tools": [<br>        "xelatex"<br>    ]<br>    },<br>    {<br>    "name": "pdflatex -&gt; bibtex -&gt; pdflatex*2",<br>    "tools": [<br>        "pdflatex",<br>        "bibtex",<br>        "pdflatex",<br>        "pdflatex"<br>    ]<br>    },<br>    {<br>        "name":"pdflatex",<br>        "tools": [<br>            "pdflatex"<br>        ]<br>    }<br>]<br></code></pre></td></tr></tbody></table></figure><p>主要的配置是latex的编译命令以及流程化的一些编译过程。latex.tools里面是常用的编译命令，例如latexmk，pdflatex，xelatex等，需要配置好这些命令的参数。latex.recipe主要是一些编译链，用于文档的编译。然后latex插件中显示的编译选项就是对应于latex.recipe的内容。例如这里比较常用的latexmk直接编译，以及涉及到参考文献引用的pdflatex-&gt;bibtex-&gt;pdflatex-&gt;pdflatex的编译链等。</p><p>以上就是Ubuntu下Latex环境配置以及vscode环境配置的主要内容了。配置完成后基本就能用了，还有一些其他的细节后续可以根据自己的习惯去添加。例如安装sumatra PDF插件，安装Latex英文词库语法插件等。最后，个人建议用vscode写latex时，很有必要开启自动换行，不然手动回车换行会很麻烦，而且后期改起来也很麻烦。打开的方式就是在vscode的设置中，找到Word Wrap选项，然后改成wordwrapcolumn。</p>]]></content>
    
    
    <categories>
      
      <category>SOFTWARE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统下连接校园网（ZJU VPN）</title>
    <link href="/2021/07/28/Software/ZJU-VPN-connection-in-Linux/"/>
    <url>/2021/07/28/Software/ZJU-VPN-connection-in-Linux/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="软件安装">软件安装</h2><p>在Linux系统下连接校园网和Windows稍有不同，需要使用命令行连接。但是基本过程是一样的，以下为主要步骤： 1. 设置系统的IP地址。如果有固定分配的IP，那么就在网络选项理设置IP地址。如图1所示。</p><p><img src="/img/ZJU-VPN-connection-in-Linux/1.png"></p><ol start="2" type="1"><li>安装xl2tpd。这是VPN设置必要的软件包，由于校园网是以VPN的形式搭建的，所以需要这个安装包，访问校内和校外网址。安装方法为如下命令：</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install xl2tpd<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>安装zjunet。这是zju vpn连接的命令行工具，是依赖xl2tpd的，所以需要先进行步骤2。软件的网址是：[zjunet][https://github.com/QSCTech/zjunet]。找到最新的release版本，然后下载安装包。以Ubuntu为例，下载*.deb文件，先cd到安装包所在路径，然后用如下命令安装：</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo dpkg -i *.deb<br></code></pre></td></tr></tbody></table></figure><ol start="4" type="1"><li>完成上述步骤后，终端输入zjunet可以查看对应的参数以及帮助文档，如图2所示。</li></ol><p><img src="/img/ZJU-VPN-connection-in-Linux/2.png"></p><p>以上就完成了对应软件安装，下面是zjunet的基本使用教程</p><h2 id="zjunet使用">zjunet使用</h2><p>zjunet的使用参数有很多，对大部分人来说，主要的应用场景应该还是连接校园网。所以下面只介绍如何连接校园网。主要有以下几步。</p><ol type="1"><li>输入你的账号和密码。先输入账号密码，软件会自动记录，下次登录时可以省略这步。配置命令如下。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zjunet user add<br></code></pre></td></tr></tbody></table></figure><p>然后终端会提示你输入账号和密码，如图3所示。</p><p><img src="/img/ZJU-VPN-connection-in-Linux/3.png"></p><ol start="2" type="1"><li>输入账号和密码后，就可以直接连接校园网了，连接命令如下。终端可能会显示retrying，这个属于正常现象，不是配置的问题。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zjunet vpn -c<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>连接成功如图4所示。</li></ol><p><img src="/img/ZJU-VPN-connection-in-Linux/4.png"></p><ol start="4" type="1"><li>如果想断开连接，可以输入如下命令，即可断开连接，断开连接后的提示如图5所示。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zjunet vpn -d<br></code></pre></td></tr></tbody></table></figure><p><img src="/img/ZJU-VPN-connection-in-Linux/5.png"></p>]]></content>
    
    
    <categories>
      
      <category>SOFTWARE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>vpn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt Deploy</title>
    <link href="/2021/07/06/Software/Qt-Deploy/"/>
    <url>/2021/07/06/Software/Qt-Deploy/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="发布带运行环境的qt执行文件">发布带运行环境的Qt执行文件</h1><p>在VS中生成release版本的exe文件后，文件会依赖于使用的lib以及dll文件等。这样换一个运行环境后，可能会无法运行当前的文件。例如基于Qt的exe文件，会依赖于Qt的lib和dll。Qt提供了此问题的解决办法。</p><h2 id="解决方法">解决方法</h2><ol type="1"><li>打开Qt提供的cmd窗口</li><li>cd到release版本的exe所在的位置</li><li>运行 windeployqt file_name.exe</li><li>当前文件夹下的文件就是对应exe文件所需的运行环境 上述操作生成的dll文件以及运行环境，能保证exe文件在没有安装qt环境的PC上运行。此方法只适用于windows系统（运行指令的意思就是win deploy qt的意思）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>DEVELOPMENT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS中Debug和Release的区别</title>
    <link href="/2021/07/06/Software/Difference-in-Debug-and-Release/"/>
    <url>/2021/07/06/Software/Difference-in-Debug-and-Release/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题1">问题1</h2><h3 id="问题描述">问题描述</h3><p>在搭建EMG信号处理系统时，我需要读取一个txt文件。在debug时能正常读取。在release版本下却不能获取其中的信息。后来发现问题在于我使用了assert语句。我的读取代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Config::gen_data_list</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-function">QFile <span class="hljs-title">f</span><span class="hljs-params">(select_dataset_path)</span></span>;<br><span class="hljs-built_in">assert</span>(f.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text));<br><span class="hljs-keyword">while</span> (!f.<span class="hljs-built_in">atEnd</span>())<br>{<br>QString l = f.<span class="hljs-built_in">readLine</span>();<br><span class="hljs-built_in">qDebug</span>() &lt;&lt; l &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (l.<span class="hljs-built_in">compare</span>(<span class="hljs-string">'\n'</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span><br>data_list.<span class="hljs-built_in">append</span>(l.<span class="hljs-built_in">simplified</span>());<br>}<br>data_num = data_list.<span class="hljs-built_in">length</span>();<br>trial_num = data_num * blk_num;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="解决办法">解决办法</h3><p>在release条件下，data_num始终是0。因为assert语句被忽略掉了，所以txt文件一直都没有被读取。将代码改成如下形式，release版本下也能正常读取了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Config::gen_data_list</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-function">QFile <span class="hljs-title">f</span><span class="hljs-params">(select_dataset_path)</span></span>;<br><span class="hljs-type">bool</span> isOpen = f.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text);<br><span class="hljs-built_in">assert</span>(isOpen);<br><span class="hljs-keyword">while</span> (!f.<span class="hljs-built_in">atEnd</span>())<br>{<br>QString l = f.<span class="hljs-built_in">readLine</span>();<br><span class="hljs-built_in">qDebug</span>() &lt;&lt; l &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (l.<span class="hljs-built_in">compare</span>(<span class="hljs-string">'\n'</span>) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span><br>data_list.<span class="hljs-built_in">append</span>(l.<span class="hljs-built_in">simplified</span>());<br>}<br>data_num = data_list.<span class="hljs-built_in">length</span>();<br>trial_num = data_num * blk_num;<br>}<br></code></pre></td></tr></tbody></table></figure><p>这样isOpen的值取决于文件是否打开。所以f.open(QIODevice::ReadOnly | QIODevice::Text)这部分的内容一定会被执行的。 在VS中，也可以在属性中打开编译调试代码开关，这样就会编译assert函数了。</p><h3 id="原因探究">原因探究</h3><p>查阅相关资料后，我发现assert语句在windows下，利用VC的编译器时，会被忽略掉而不执行。这取决于release和debug时的编译器优化方式。在linux条件下，使用gcc编译时则不会忽略assert语句。其他深入的编译原理相关的原因就不再接着探究了。</p><p>总的来说，不管使用何种编译器，代码规范化是很重要的。assert语句不应该被用来检测文件读取，以及输入是否合法等问题。也不能把赋值操作等语句放在其中。总之，检查代码的时候，把assert语句去掉，如果代码的正常逻辑没有问题。那么代码就是正常的。assert应该是用来检测参数的合法性以及参数值的大小等涉及代码完备性和安全性的问题。</p><h2 id="问题2">问题2</h2><h3 id="问题描述-1">问题描述</h3><p>在搭建EMG信号处理系统时，需要通过state参数来判断是否暂停函数中的for循环。在debug条件下，暂停和恢复都能正常运行。暂停条件下停止实验也能正常运行，但是在release条件下，暂停后就没法恢复正常运行了，而且暂停后要么会在下一个trial时停止，要么在后面恢复时，没有响应。代码块如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= exp_c.blk_num; i++){<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= exp_c.data_num; j++){<br>        <span class="hljs-keyword">if</span> (th_record_state == <span class="hljs-number">2</span>){<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>){<br>                <span class="hljs-keyword">if</span> (main_th_stop){<br>                    <span class="hljs-built_in">stop_experiment</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                }<br>                <span class="hljs-keyword">if</span> (th_record_state == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= state_num; k++){<br>            <span class="hljs-built_in">Process</span>();<br>        }<br></code></pre></td></tr></tbody></table></figure><p>需要实现的功能是，在th_record_state为1（record state）时，实验正常进行；在th_record_state为2（pause state）时，实验暂停；在th_record_state为0时，main_th_stop为true，实验结束。</p><h3 id="解决办法-1">解决办法</h3><p>由于release版本下，VS的优化器认为while循环中的内容对外部代码没有影响，且while循环会占用很多计算量。所以在release版本下，while循环中的代码会被忽略掉。所以在while循环中加入延时，减少因为暂停导致的循环次数。这样优化器会重新加入while循环的内容。（这部分涉及到VS中的编译优化的问题，没有深究原因）。修改后的代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= exp_c.blk_num; i++){<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= exp_c.data_num; j++){<br>        <span class="hljs-keyword">if</span> (th_record_state == <span class="hljs-number">2</span>){<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>){<br>                <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">100</span>);<br>                <span class="hljs-keyword">if</span> (main_th_stop){<br>                    <span class="hljs-built_in">stop_experiment</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                }<br>                <span class="hljs-keyword">if</span> (th_record_state == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= state_num; k++){<br>            <span class="hljs-built_in">Process</span>();<br>        }<br></code></pre></td></tr></tbody></table></figure><p>尽管这样会损失一些反应时间，但是实验系统对反应时间的要求也不高，而且Sleep函数的时间可以根据实验所需的反应时间修改。这种解决方案也可以接受。</p><h3 id="原因探究-1">原因探究</h3><p>主要的原因还是debug和release版本下，VS的优化方法不一样。优化的参数可以在项目属性中调整。但是release版本的代码对稳定性的要求会更高，类似于数组越界，指针赋值等问题，在debug时可能没问题。但是release时就会出现问题。此时一定要检查代码的规范性问题，以及代码中的一些合理性问题，例如本文中出现的assert语句中加入文件读取语句，while循环不加延时导致大量无效循环等问题。</p>]]></content>
    
    
    <categories>
      
      <category>DEVELOPMENT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>compile</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>powershell命令：tree</title>
    <link href="/2021/06/10/Software/powershell-commands-tree/"/>
    <url>/2021/06/10/Software/powershell-commands-tree/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>显示文件夹中的文件结构，并生成txt文件或md文件。 用法如下：</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">tree [<span class="hljs-type">drive</span>:][<span class="hljs-type">path</span>] [/<span class="hljs-type">F</span>] [/<span class="hljs-type">A</span>] &gt;[<span class="hljs-type">PRN</span>]<br>[/<span class="hljs-type">F</span>]: 显示目录下的文件名<br>[/<span class="hljs-type">A</span>]: 使用ASCII码字符<br>[<span class="hljs-type">PRN</span>]: 存储生成的文件结构的txt或<span class="hljs-built_in">md</span>文件<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>SOFTWARE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>powershell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 环境变量设置</title>
    <link href="/2021/06/01/Software/Linux-Environment-Variable/"/>
    <url>/2021/06/01/Software/Linux-Environment-Variable/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux环境变量在<sub>/.bashrc文件中设置。也可能在</sub>/.zshrc，也可能在/etc/profile中。设置的方法是</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=“$PATH:/yourpath/”<br></code></pre></td></tr></tbody></table></figure><p>一般是放在所有环境变量最后的。也可以放在最前面。我安装texlive的时候，放在最前面的写法没有反应。放在最后面能正常运行pdflatex等命令。然后就是路径一定要用双引号扩起来，冒号和路径之间不能有空格</p>]]></content>
    
    
    <categories>
      
      <category>SOFTWARE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual Studio Code 配置c++编译环境</title>
    <link href="/2021/05/31/Software/visual-studio-code-cpp-configure/"/>
    <url>/2021/05/31/Software/visual-studio-code-cpp-configure/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="原因">原因</h2><p>平时写c++大部分时间是在windows环境下，然后用Visual Studio调试和编译代码。但是由于笔记本的系统是macOS，有时候需要远程调试代码。远程调试用Teamviewer或者Microsoft Remote Desktop的话，还是不太方便。再加上也想学习一下g++编译器。相较于msvc，g++跨平台的特性更加实用。</p><h2 id="配置">配置</h2><ol type="1"><li>安装g++编译器（windows：MinGW，linux：sudo安装，macOS: brew安装）。必装的项目有g++，gcc，gdb，</li><li>vscode安装C++扩展（C/C++）</li><li>配置lanuch.json和tasks.json文件。以下是标准的launch.json文件和tasks.json文件</li></ol><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json">lanuch.json<br><span class="hljs-attr">"configurations"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">{</span><br>            <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"生成和调试活动文件"</span><span class="hljs-punctuation">,</span> <br>            <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cppdbg"</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"request"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"launch"</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"program"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"${workspaceFolder}/${fileBasenameNoExtension}.exe"</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"args"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"stopAtEntry"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"cwd"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"${workspaceFolder}"</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"environment"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"externalConsole"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"MIMode"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"gdb"</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//调试模式</span><br>            <span class="hljs-attr">"miDebuggerPath"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"D:\\MinGW\\bin\\gdb.exe"</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"preLaunchTask"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"g++"</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"setupCommands"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">{</span><br>                    <span class="hljs-attr">"description"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"为 gdb 启用整齐打印"</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">"text"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"-enable-pretty-printing"</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">"ignoreFailures"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>                <span class="hljs-punctuation">}</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">}</span><br>    <span class="hljs-punctuation">]</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json">tasks.json<br><span class="hljs-punctuation">{</span><br>    <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2.0.0"</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">"tasks"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">{</span><br>            <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"shell"</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"label"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"g++"</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"D:\\MinGW\\bin\\g++.exe"</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"args"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">"-g"</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">"${file}"</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">"-o"</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">"${workspaceFolder}\\${fileBasenameNoExtension}.exe"</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"options"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br>                <span class="hljs-attr">"cwd"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"D:\\MinGW\\bin"</span><br>            <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"problemMatcher"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">"$gcc"</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"group"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"build"</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">"detail"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"调试器生成的任务。"</span> <span class="hljs-comment">//注意和lanuch.json中的文件匹配</span><br>        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></tbody></table></figure><p>然后就是写代码编译生成可执行文件了。这部分和g++编译器的内容相关。后面继续学习g++编译器。</p>]]></content>
    
    
    <categories>
      
      <category>SOFTWARE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Optimal Linear Estimation</title>
    <link href="/2021/05/28/MachineLearning/Optimal-Linear-Estimation/"/>
    <url>/2021/05/28/MachineLearning/Optimal-Linear-Estimation/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景">背景</h2><p>最优线性估计算法是神经解码中一种比较常用的算法。在算法刚提出来的时候，其解码精度和解码速度都属于较高的水准，因此在脑机接口实验中应用广泛。随着神经网络的兴起以及传统机器学习算法的更新，BCI领域用来解码的算法也越来越多，例如KF，UKF，RNN，CNN等。OLE尽管计算精度不如目前的算法，但是计算量小，反馈迅速。因此目前在线的BCI实验OLE的应用仍然较多。</p><h2 id="算法推导">算法推导</h2><p>OLE算法是PVA算法的改进，PVA算法在之前的Blog中有提到，是BCI中应用最早的算法。但是PVA有自己的缺陷，即很依赖数据的质量。这里的质量指的是用于解码的神经元集群的偏好方向分布。如果偏好方向的分布不均匀，朝某个方向的神经元占大多数，那么解码得到的方向就会偏向于这个方向，导致朝其他方向的运动很困难。为了解决这个问题，Chase等人提出了对于PVA算法的改进方法，即OLE算法[1]。 OLE算法的核心思想就是利用线性插值的方法，把神经元的偏好方向调整到尽量在各个方向都是均匀分布的。我们假设有2个神经元，偏好方向如图1中红色和蓝色的虚线所示。当朝各个方向运动时，神经元的发放率变化程度会不一样。当朝着神经元偏好方向运动时，神经元会更活跃，朝反方向运动时，会更加被抑制。但是当朝着垂直于偏好方向的方向运动时，神经元的发放率不会有明显变化，此时，解码误差会很大，或者说，很难解码到朝这个方向的运动。 为了便于理解这个问题，我们可以用一个更极端的假设，即所有神经元的偏好方向都朝向x轴正方向，那么此时对于y轴的运动，是无法通过神经元解码得到的。PVA的计算公式里，y轴运动的参数<span class="math inline">\(b_1\)</span>是0。这里有一个需要理解的概念，即神经元集群的解码，不是取决于神经元的发放率，而是发放率的变化。朝哪个方向运动能有神经元有强烈的发放率变化，那么朝这个方向的运动解码就准确。</p><figure><img src="/img/Optimal-Linear-Estimation/1.png" alt=""><figcaption>图1: Bias Preferred Direction</figcaption></figure><p>为了解决上述问题，Chase等人提出了OLE算法，具体的计算方法如下： 假设神经元的发放率为<span class="math inline">\(r(t)\)</span>。神经元的偏好方向矩阵为<span class="math inline">\(B\)</span>，当前的运动方向为<span class="math inline">\(d(t)\)</span>。那么有： <span class="math display">\[r(t) = B * d(t) + \epsilon(t) \]</span> 其中<span class="math inline">\(\epsilon(t)\)</span>表示<span class="math inline">\(t\)</span>时刻的噪声。假设神经元的个数为<span class="math inline">\(N\)</span>，那么<span class="math inline">\(r(t) \in R^{Nx1}\)</span>。假设解码的维度为<span class="math inline">\(d\)</span>，那么<span class="math inline">\(B \in R^{Nx(d+1)}\)</span>。这里加1表示常数项。 那么，预测的运动方向为： <span class="math display">\[d_{pred}(t) = (B'B)^{-1}B'r(t)\]</span> 以上就是OLE算法的计算内容。和PVA算法比较，似乎没什么太大的差别。但是思想是不同的。 首先，PVA的计算，前提假设就包括了神经元的分布是均匀的。体现在这里，即<span class="math inline">\(B'B=I\)</span>，其中<span class="math inline">\(I\)</span>表示单位矩阵。那么上述公式可以写为：<span class="math inline">\(d_{pred}(t) = B'r(t)\)</span>。即PVA的计算方法，单独计算每个神经元的发放率，然后计算在当前偏好方向的投影，然后求和之后得到预测的运动方向。 对于OLE的计算，更加像是先计算了神经元分布的均匀度。然后根据不同方向的运动权重重新分布当前的偏好方向。使得神经元分布更加均匀。即<span class="math inline">\(B'B\)</span>这个矩阵的计算值，也就是运动维度的协方差。这里举个例子，假设所有神经元的偏好方向都是x轴正方向，那么<span class="math inline">\(B'B=[[1, 1], [0, 0]]\)</span>。 这个时候x轴和y轴的运动都会存在。即我们把神经元的偏好方向从x轴正方向旋转了45度。Chase的文章中的图可以很好的解释这个原理：</p><figure><img src="/img/Optimal-Linear-Estimation/2.png" alt=""><figcaption>图2: Optimal Prefered Direction</figcaption></figure><p>需要注意的是，<span class="math inline">\(B\)</span>矩阵的计算方法和PVA算法是一致的。 以上就是OLE算法的计算过程了，OLE的计算方法和PVA很像，但是解决了神经元分布不均匀的问题。这个问题在BCI中很常见，所以OLE相较于PVA，效果一般都是会更好的。还有一种改进版的OLE算法-'full OLE'。之前介绍的这种是'minimal OLE'。 ‘full OLE' 相较于'minimal OLE'的区别在于其假设了神经信号中存在了同源或相似的噪声。那么在计算过程中，这种噪声会体现在解码的结果上，导致运动方向产生误差。其改进方法也很简单，只是在预测公式中，加入了所有通道神经元的协方差矩阵，如下： <span class="math display">\[d_{pred}(t) = (B'\Sigma B)^{-1}B'r(t)\]</span> 这里的<span class="math inline">\(\Sigma\)</span>就是协方差矩阵，如果神经信号之间没有相关性，即没有同源噪声的话，<span class="math inline">\(\Sigma = I\)</span>。也就是'minial OLE'的计算方法了。</p><h2 id="代码">代码</h2><p>后续会附上代码链接</p><h2 id="参考文献">参考文献</h2><p>[1] S. M. Chase, A. B. Schwartz, and R. E. Kass, "Bias, optimal linear estimation, and the differences between open-loop simulation and closed-loop performance of spiking-based brain–computer interface algorithms," Neural networks, vol. 22, no. 9, pp. 1203-1213, 2009.</p>]]></content>
    
    
    <categories>
      
      <category>MACHINE LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OLE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZJU RVPN 初始化失败的解决办法</title>
    <link href="/2021/05/03/Software/ZJU%20RVPN%20Initialize%20Failed/"/>
    <url>/2021/05/03/Software/ZJU%20RVPN%20Initialize%20Failed/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题描述">问题描述</h3><p>在 macOS系统，遇见easyconnect一直提示初始化失败的问题。重新安装后仍旧不能解决问题。后发现是macOS系统开机时禁止启动了两个easyconnect的进程。分别为： 1. com.sangfor.EasyMonitor.plist 2. com.sangfor.ECAgentProxy.plist 禁止后easyconnect无法启动代理，连接校内网络</p><h3 id="解决办法">解决办法</h3><p>用软件Tencent Lemon设置开机启动项，在“未知应用“选项中找到对应的进程，打开开机启动项。然后重启电脑，即可解决问题</p>]]></content>
    
    
    <categories>
      
      <category>SOFTWARE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vpn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小二乘法</title>
    <link href="/2020/04/17/MachineLearning/Linear-Square-Method/"/>
    <url>/2020/04/17/MachineLearning/Linear-Square-Method/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几天看书的时候突然注意到了这个经典的优化方法，于是重新推导了一遍，为以后应用做参考。</p><h2 id="背景">背景</h2><p>最小二乘法应该是我接触的最早的优化方法，也是求解线性回归的一种方法。线性回归的主要作用是用拟合的方式，求解两组变量之间的线性关系（当然也可以不是线性的，那就是另外的回归方法了）。也就是把一个系统的输出写成输入的线性组合的形式。而这组线性关系的参数求解方法，就是最小二乘法。</p><p>我们从最简单的线性回归开始，即输入和输出都是1维的。此时，最小二乘法也是最简单的。</p><p>假设有输入信号<span class="math inline">\(x = \{x_0, x_1, ..., x_t\}\)</span>，同时输出信号为<span class="math inline">\(y = \{y_0, y_1, ..., y_t\}\)</span>，我们假设输入信号<span class="math inline">\(x\)</span>和输出信号<span class="math inline">\(y\)</span>之间的关系可以写成如下形式：</p><p><span class="math display">\[y_{pre} = ax+b \tag{1}\]</span></p><p>我们需要求解最优的<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>，这里最优的含义就是，预测的最准确，也就是预测值和真实值的误差最小，即：</p><p><span class="math display">\[arg\, min_{a, b}{\sum_{i=0}^{t}{(y_i-ax_i-b)^2}} \tag{2}\]</span></p><p>我们假设误差函数为：</p><p><span class="math display">\[err = \sum_{i=0}^{t}{(y_i-ax_i-b)^2} \tag{3}\]</span></p><p><span class="math inline">\(err\)</span>对<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>分别求偏导：</p><p><span class="math display">\[\frac{\partial{err}}{\partial{a}} = \sum_{i=0}^{t}{2(ax_i+b-y_i)*x_i} \tag{4}\]</span></p><p><span class="math display">\[\frac{\partial{err}}{\partial{b}} = \sum_{i=0}^{t}{2(ax_i+b-y_i)} \tag{5}\]</span></p><p>根据极值定理，有<span class="math display">\[\frac{\partial{err}}{\partial{a}}=0\]</span>，且<span class="math display">\[\frac{\partial{err}}{\partial{b}}=0\]</span>，所以有：</p><p><span class="math display">\[\sum_{i=0}^{t}{2(ax_i+b-y_i)} = 0 \tag{6}\]</span></p><p><span class="math display">\[\sum_{i=0}^{t}(y_i - ax_i) = \sum_{i=0}^{t}{b} \tag{7}\]</span></p><p><span class="math display">\[\sum_{i=0}^{t}{y_i} - a * \sum_{i=0}^{t}{x_i} = (t+1)*b \tag{8}\]</span></p><p><span class="math display">\[b = \bar{y} - a\bar{x} \tag{9}\]</span></p><p>其中，<span class="math inline">\(\bar{y}\)</span>表示<span class="math inline">\(y\)</span>的均值，<span class="math inline">\(\bar{x}\)</span>表示<span class="math inline">\(x\)</span>的均值。将Eq(9)代入Eq(4)，有：</p><p><span class="math display">\[\sum_{i=0}^{t}{2(ax_i+b-y_i)*x_i} = 0 \tag{10}\]</span></p><p><span class="math display">\[\sum_{i=0}^{t}{ax_i^2} + \sum_{i=0}^{t}bx_i = \sum_{i=0}^{t}{y_ix_i} \tag{11}\]</span></p><p><span class="math display">\[a\sum_{i=0}^{t}x_i^2 + \bar{x}(\bar{y}-a\bar{x}) = \sum_{i=0}^{t}{x_iy_i} \tag{12}\]</span></p><p><span class="math display">\[a(\sum_{i=0}^{t}{x_i^2 - \bar{x}^2}) = \sum_{i=0}^{t}{x_iy_i}-\bar{x}\bar{y} \tag{13}\]</span></p><p><span class="math display">\[a = \frac{\sum_{i=0}^{t}{x_iy_i}-\bar{x}\bar{y}}{\sum_{i=0}^{t}{x_i^2 - \bar{x}^2}} \tag{14}\]</span></p><p>所以Eq(14)和Eq(9)就是最简单的最小二乘法的计算方法。</p><p>然后我们进一步考虑，如果输入和输出是多维数据，要如何计算。</p><p>假设输入信号为<span class="math inline">\(X \in R^{m*t}\)</span>， 输出信号为<span class="math inline">\(Y \in R^{n*t}\)</span>，那么有：</p><p><span class="math display">\[Y = W_0X+B = WX_1 \tag{15}\]</span></p><p>其中<span class="math inline">\(W_0 \in R^{n*m}\)</span>是回归矩阵的系数，<span class="math inline">\(B \in R^{1*t}\)</span>表示常数项，这里可以直接写到<span class="math inline">\(W\)</span>矩阵中。<span class="math inline">\(W \in R^{(m+1)*t}\)</span>，<span class="math inline">\(X_1 \in R^{(m+1)*t}\)</span> <span class="math display">\[X_1 = \begin{bmatrix}x_{11} &amp;x_{12} &amp; ... &amp;x_{1t}\\x_{11} &amp;x_{12} &amp; ... &amp;x_{1t}\\{\vdots} &amp;{\vdots} &amp;... &amp;{\vdots}\\x_{m1} &amp;x_{m2} &amp;... &amp;x_{mt}\\1 &amp;1 &amp;... &amp;1\\\end{bmatrix} \tag{16}\]</span></p><p>所以有：</p><p><span class="math display">\[\arg min_{W}({Y-WX_1}) \tag{17}\]</span></p><p>假设误差函数为<span class="math inline">\(E\)</span>，则有：</p><p><span class="math display">\[E = (Y-WX_1)(Y-WX_1)^T = YY^T - WX_1Y^T-YX_1^TW^T+WX_1X_1^TW^T \tag{18}\]</span></p><p>计算<span class="math inline">\(E\)</span>对<span class="math inline">\(W\)</span>的偏导，则该偏导等于0：</p><p><span class="math display">\[\frac{\partial{E}}{\partial{W}} = -X_1Y^T-X_1^TY + 2WXX^T = 0 \tag{19}\]</span></p><p>所以有：</p><p><span class="math display">\[W = (X_1X_1^T)^{-1}X_1Y^T \tag{20}\]</span></p><p>至此矩阵形式的最小二乘法（多元线性回归的参数解法）推导完成。注意这里的<span class="math inline">\(X_1\)</span>和<span class="math inline">\(Y\)</span>中的数据排列方式为：每一行是一个维度的数据，每一列表示一个时间点。如果不是这么记录的话，那么公式需要加上转置。</p><p>后续会附上代码链接</p>]]></content>
    
    
    <categories>
      
      <category>MACHINE LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>least square method</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>维纳滤波</title>
    <link href="/2020/04/13/MachineLearning/Wiener-Filter/"/>
    <url>/2020/04/13/MachineLearning/Wiener-Filter/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为最近看文章接触了维纳滤波，所以这里写一下Weiner Filter的一些简单理解和推导。</p><h2 id="基本定义">基本定义</h2><p>维纳滤波是一种在含噪声的时序信号把信号提取出来的滤波器，其基本框图如下：</p><figure><img src="/img/Wiener-Filter/1.jpg" alt=""><figcaption>图-1：简单的Wiener-Filter</figcaption></figure><p>简单的维纳滤波其实就是通过一个FIR滤波器，去除噪声的过程。在这里，<span class="math inline">\(h\)</span>的作用也可以理解为： 通过训练集的数据对信号和噪声的建模，然后通过前几个点的信息，预测当前时刻的噪声信号所占的比例，然后去除掉，剩下的就是预测的时序信号了。维纳滤波作为一种使用很广泛的滤波器，其变化的形式也有很多种，可以是单输入输出的，也可以是多输入输出的。<span class="math inline">\(h\)</span>所表示的变换也可以写成非线性；<span class="math inline">\(h\)</span>可以是有限长的FIR滤波器，也可以是无限长的IIR滤波器。要取决于当前你所解决的问题。但是维纳滤波的基本思想还是一致的。通过滤波（矩阵或者其他模型的形式）来从信号和噪声的混合中提取信号。所以维纳滤波的核心，就是计算这个滤波器（矩阵<span class="math inline">\(h\)</span>或者模型的参数）。也就是解Wiener-Hopf方程。</p><p>本文用比较简单的单输入输出，且只考虑有限长滤波（即认为当前时刻的信号只和前有限个时间点的信号相关）。</p><h2 id="公式推导">公式推导</h2><p>首先，对于图1中的滤波器：</p><p><span class="math display">\[ y(n) = x(n) * h(n) = (s(n)+v(n))*h(n) \]</span></p><p>其中<span class="math inline">\(*\)</span>表示卷积，<span class="math inline">\(x(n)\)</span>表示输入信号， <span class="math inline">\(y(n)\)</span>表示输出信号， <span class="math inline">\(s(n)\)</span>表示输入信号中，有用的信号部分；<span class="math inline">\(v(n)\)</span>表示输入信号中的噪声部分。</p><p>维纳滤波的目标是，保证输出<span class="math inline">\(y(n)\)</span>和真实信号<span class="math inline">\(s(n)\)</span>的差别最小，由于<span class="math inline">\(y(n)\)</span>和<span class="math inline">\(s(n)\)</span>是时序信号，所以要保证两者的均方误差最小，所以有：</p><p><span class="math display">\[E\{e^2(n)\} = E\{(y(n)-s(n))^2\} = E\{(x(n)*h(n)-s(n))^2\} \]</span></p><p>即求使得<span class="math inline">\(E\{e^2(n)\}\)</span>最小的<span class="math inline">\(h\)</span>。所以<span class="math inline">\(E\{e^2\}\)</span>对<span class="math inline">\(h\)</span>求偏导。有：</p><p><span class="math display">\[\frac{\partial{E\{e^2(n)\}}}{\partial{h}} = 2E\{e(n) * \frac{\partial{e(n)}}{\partial{h}}\} = 0 \]</span></p><p><span class="math display">\[\frac{\partial{E\{e^2(n)\}}}{\partial{h}} = 2E\{[\sum_{m=0}^{N-1}{h(m)x(n-m) - s(n)}]x(n-j)\}, j = 0, 1, ... , N-1 \]</span></p><p><span class="math display">\[\frac{\partial{E\{e^2(n)\}}}{\partial{h}} = 2\sum_{m=1}^{N-1}{h(m)}E\{x(n-j)x(n-m)\} - 2E\{s(n)x(n-j)\} = 0, j = 0, 1, ..., N-1 \]</span></p><p>我们设<span class="math inline">\(x\)</span>和<span class="math inline">\(s\)</span>的相关系数为<span class="math inline">\(R_{xs}\)</span>，则有：</p><p><span class="math display">\[R_{xs}(j)=\sum_{m=0}^{N-1}{h(m)R_{xx}(j-m)}, j=0,1,...,N-1 \]</span></p><p>其中，<span class="math inline">\(R_{xx}(j-m)\)</span>表示<span class="math inline">\(x(n-j)\)</span>和<span class="math inline">\(x(n-m)\)</span>的相关系数，这里<span class="math inline">\(m\)</span>是固定的，<span class="math inline">\(j\)</span>是变化的。且<span class="math inline">\(m&gt;=0\)</span>，<span class="math inline">\(R_{xs}(j)\)</span>表示<span class="math inline">\(x(n-j)\)</span>和<span class="math inline">\(s(n)\)</span>的相关系数。上述公式中，<span class="math inline">\(n\)</span>表示的是时序信号中的时间点。</p><p>然后，根据上述式子，可以得到<span class="math inline">\(N\)</span>个线性方程： <span class="math display">\[\begin{cases}R_{xs}(0)=h(0)R_{xx}(0)+h(1)R_{xx}(1)+...+h(N-1)R_{xx}(N-1)\\R_{xs}(1)=h(1)R_{xx}(1)+h(0)R_{xx}(0)+...+h(N-1)R_{xx}(N-2)\\...\\R_{xs}(N-1)=h(N-1)R_{xx}(N-1)+h(N-2)R_{xx}(N-2)+...+h(0)R_{xx}(0)\\\end{cases} \]</span> 写成矩阵形式，有：</p><p><span class="math display">\[\displaystyle {R_{xx}H}={R_{xs}} \]</span></p><p>其中， <span class="math inline">\(\displaystyle {H} = [h(0), h(1),...,h(N-1)]^T\)</span>是需要求的滤波器参数</p><p><span class="math inline">\(\displaystyle {R_{xs}} = [R_{xs}(0),R_{xs}(1), ..., R_{xs}(N-1)]^T\)</span>是<span class="math inline">\(x\)</span>和<span class="math inline">\(s\)</span>的相关系数</p><p><span class="math display">\[\displaystyle {R_{xx}} = \begin{bmatrix}R_{xx}(0)&amp;R_{xx}(1)&amp;...&amp;R_{xx}(N-1)\\R_{xx}(1)&amp;R_{xx}(0)&amp;...&amp;R_{xx}(N-2)\\{\vdots}&amp;{\vdots}&amp;...&amp;{\vdots}&amp;\\R_{xx}(N-1)&amp;R_{xx}(N-2)&amp;...&amp;R_{xx}(0)\\\end{bmatrix} \]</span></p><p>所以根据上述公式可以求得：</p><p><span class="math display">\[\displaystyle {H} = {R_{xx}^{-1}R_{xs}} \]</span></p><p>此时，信号的均方误差最小，根据<span class="math inline">\(E\{e^2(n)\}\)</span>计算公式，可得：</p><p><span class="math display">\[ E\{e^2(n)\} = E\{(s(n)-\sum_{m=0}^{N-1}h(m)x(n-m))^2\}\]</span></p><p><span class="math display">\[ E\{e^2(n)\} = E\{s^2(n) - 2s(n)\sum_{m=0}^{N-1}h(m)x(n-m)+\sum_{m=0}^{N-1}\sum_{r=0}^{N-1}{h(m)x(n-m)h(r)x(n-r)}\}\]</span></p><p><span class="math display">\[ E\{e^2(n)\}=R_{ss}(0)-2\sum_{m=0}^{N-1}{h(m)R_{xs}(m)+\sum_{m=0}^{N-1}{h(m)}\sum_{r=0}^{N-1}{h(r)R_{xx}(n-r)}}\]</span></p><p>根据<span class="math inline">\(E\{e^2(n)\}\)</span>求导计算公式，可得：</p><p><span class="math display">\[ E\{e^2(n)\} = R_{ss}(0) - \sum_{m=0}^{N-1}{h(m)R_{xs}(n-m)} \]</span></p><p>假设信号<span class="math inline">\(s(n)\)</span>和噪声<span class="math inline">\(v(n)\)</span>互相独立，那么有：</p><p><span class="math display">\[R_{sv}= R_{vs} = 0\]</span></p><p><span class="math display">\[R_{xs} = R_{ss} + R_{vs} = R_{ss}\]</span></p><p><span class="math display">\[R_{xx} = R_{ss}+R_{sv}+R_{vs}+R_{vv} = R_{ss}+R_{vv}\]</span></p><p>则，根据上述公式，有：</p><p><span class="math display">\[E\{e^2(n)\} = R_{ss}(0) - \sum_{m=0}^{N-1}{h(m)R_{ss}(m)} \]</span></p><p>至此，最简单的维纳滤波的基本公式推导完成，如果涉及到多输入多输出的维纳滤波，会更加复杂，这里不做推导。后续会附上代码链接。</p>]]></content>
    
    
    <categories>
      
      <category>MACHINE LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Wiener Filter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梯度下降法</title>
    <link href="/2020/02/06/DeepLearning/Gradient-Descent-Method/"/>
    <url>/2020/02/06/DeepLearning/Gradient-Descent-Method/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇Blog的主要内容是关于梯度下降法的一些理解，以及相关的公式推导。梯度下降法很早之前就接触过，但是因为长时间不用，所以理解上也有了一些欠缺，今天看了一些参考文献，写一下自己的一些理解。便于以后帮助自己回忆。</p><h3 id="artificial-neural-network">Artificial Neural Network</h3><p>关于人工神经网络，这是目前使用最广泛的一类算法了。神经网络和其他的算法相比较，计算更加直接。不需要去推导公式，去计算两者的关系，直接通过网络的方式连接，然后用大量的数据训练，没有关系的连接权重逐渐变弱，有关系的权重逐渐变强。如果把输入和输出的函数关系写出来，会发现是一个很复杂的非线性公式。也正是因为这一点，神经网络的拟合程度比普通的线性，非线性算法都要好。</p><h3 id="gradient-descent">Gradient Descent</h3><p>对于用梯度下降法训练神经网络，我之前一直没有弄明白的点是<strong>为什么梯度的方向就是函数增加最快的方向</strong>， 我理解梯度方向是变化最快的方向，但是一直不理解为什么是增加的。今天看了一些参考文献，理解了一点。</p><p>对于神经网络，我们会有训练集的数据<span class="math inline">\(\{x_0, y_0\}\)</span>，<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>之间有函数关系<span class="math inline">\(y = f(x)\)</span>，函数有自己的参数<span class="math inline">\(p\)</span>，对应于神经网络的权值。所以有<span class="math inline">\(y = f(p, x)\)</span>。为了能够训练神经网络，让输出和预期值越来越接近，可以定义损失函数(Loss Function)，有<span class="math inline">\(l = L(x_0, y_0, y)\)</span>。其中<span class="math inline">\(y = f(p, x_0)\)</span>，所以：</p><p><span class="math display">\[l = L(p, y_0, x_0)\]</span></p><p>计算<span class="math inline">\(l\)</span>关于<span class="math inline">\(p\)</span>的梯度，所以：</p><p><span class="math display">\[\bigtriangledown{C_{xr}(p)} = &lt; \frac{\partial{C_{xr}}}{\partial{p^{(0)}}}, ..., \frac{\partial{C_{xr}}}{\partial{p^{(n)}}}\]</span></p><p><strong>沿梯度方向，损失函数<span class="math inline">\(l\)</span>的值是逐渐增加的</strong></p><p>对这句话的理解，在于是什么量沿着梯度方向的变化。应该是自变量<span class="math inline">\(p\)</span>。例如：</p><p>当<span class="math inline">\(\frac{\partial{C_{xr}}}{\partial{p^{(0)}}}（p_0） &gt; 0\)</span>时，也就是说，函数<span class="math inline">\(l(p^{0})\)</span>在<span class="math inline">\(p_0\)</span>点时，函数曲线沿<span class="math inline">\(p=p^0\)</span>的切线斜率是大于0的，也就是说，在很小的一个区间<span class="math inline">\((p_0-\delta, p_0+\delta)\)</span>，如果<span class="math inline">\(p_1 &gt; p_0\)</span>， 那么有<span class="math inline">\(l(p_1) &gt; l(p_0)\)</span>。所以，如果沿着梯度的负方向，损失函数的值也会降低。<strong>对于梯度大于0，会比较好理解，因为<span class="math inline">\(l\)</span>是增函数</strong>。</p><p>如果<span class="math inline">\(\frac{\partial{C_{xr}}}{\partial{p^{(0)}}}(p_0) &lt; 0\)</span>，那么有<span class="math inline">\(l(p^0)\)</span>是减函数，也就是说，函数在<span class="math inline">\(p_0\)</span>点沿<span class="math inline">\(p = p^0\)</span>的切线斜率是小于0的。即，在很小的一个区间<span class="math inline">\((p_0-\delta, p_0+\delta)\)</span>，如果<span class="math inline">\(p_1 &gt; p_0\)</span>， 那么有<span class="math inline">\(l(p_1) &lt; l(p_0)\)</span>。但是由于梯度本身小于0，所以梯度的反方向就是<span class="math inline">\(p^0\)</span>递增的方向。又因为<span class="math inline">\(l(p^0)\)</span>是减函数，所以沿梯度的负方向，<span class="math inline">\(l(p^0)\)</span>还是会逐渐降低。</p><h3 id="neural-network中梯度下降法的推导">Neural Network中梯度下降法的推导</h3><p>这里用最简单的全连接网络为例，如图所示：</p><figure><img src="/img/Gradient-Descent/1.png" alt=""><figcaption>全连接网络</figcaption></figure><p><span class="math inline">\(x\)</span>：网络的输入值；<span class="math inline">\(w_1, w_2, w_3\)</span>：层与层的连接参数；<span class="math inline">\(h_1, h_2\)</span>：中间层的输入值；<span class="math inline">\(o_1,o_2\)</span>：中间层的输出值；<span class="math inline">\(y\)</span>：网络的输出值</p><p>假设输入参数的个数为<span class="math inline">\(m\)</span>，输出参数的个数为<span class="math inline">\(n\)</span>，第一层的神经元个数为<span class="math inline">\(a\)</span>，第二层的神经元参数为<span class="math inline">\(b\)</span>，所以：</p><p><span class="math inline">\(x \in R^{1*m}\)</span>； <span class="math inline">\(y \in R^{1*n}\)</span>； <span class="math inline">\(h_1, o_1 \in R^{1*a}\)</span>； <span class="math inline">\(h_2, o_2 \in R^{1*b}\)</span>； <span class="math inline">\(w_1 \in R^{m*a}\)</span>； <span class="math inline">\(w_2 \in R^{a*b}\)</span>； <span class="math inline">\(w_3 \in R^{b*n}\)</span> 网络中每层的激活函数(activation function)用sigmoid函数：</p><p><span class="math inline">\(f(x) = \frac{1}{1+e^{-x}}\)</span></p><p>sigmoid函数的导数有如下特点(可以自己推导)：</p><p><span class="math inline">\(f'(x) = f(x)*(1-f(x))\)</span></p><p>假设用来训练的数据集为<span class="math inline">\(&lt;x, r&gt;\)</span>，<span class="math inline">\(x\)</span>为输入值，<span class="math inline">\(r\)</span>为输出值</p><p>损失函数为：</p><p><span class="math inline">\(L = \frac{1}{2}*(y-r)^{2}\)</span></p><p>所以有如下公式：</p><p><span class="math display">\[h_1=w_1*x+b_1\]</span></p><p><span class="math display">\[o_1=sigmoid(h_1)\]</span></p><p><span class="math display">\[h_2=w_2*o_1+b_2\]</span></p><p><span class="math display">\[o_2=sigmoid(h_2)\]</span></p><p><span class="math display">\[h_3=w_3*o_2+b_3\]</span></p><p><span class="math display">\[y=sigmoid(h_3)\]</span></p><p>计算<span class="math inline">\(L\)</span>关于<span class="math inline">\(w_3\)</span>的梯度，有：</p><p><span class="math display">\[\frac{\partial{L}}{\partial{w_3}}=(y-r)*\frac{\partial{(y-r)}}{\partial{w_3}}\]</span></p><p><span class="math display">\[=(y-r)*\frac{\partial{(y-r)}}{\partial{h_3}}*\frac{\partial{h_3}}{\partial{w_3}}\]</span></p><p><span class="math display">\[= (y-r)*(y-r)*[1- (y-r)]*o_2\]</span></p><p><span class="math display">\[= (y-r)^{2} * (1-y+r) * o_2\]</span></p><p>类似的，可以得到：</p><p><span class="math display">\[\frac{\partial{L}}{\partial{b_3}}=(y-r)^{2}*(1-y+r)\]</span></p><p><span class="math display">\[\frac{\partial{L}}{\partial{w_2}}=(y-r)^{2} * (1-y+r) * w_3 * o_2 * (1-o_2) * o_1\]</span></p><p><span class="math display">\[\frac{\partial{L}}{\partial{b_2}}=(y-r)^{2} * (1-y+r) * w_3 * o_2 * (1-o_2)\]</span></p><p><span class="math display">\[\frac{\partial{L}}{\partial{w_1}}=(y-r)^{2} * (1-y+r) * w_3 * o_2 * (1-o_2) * o_1 * (1-o_1) * x\]</span></p><p><span class="math display">\[\frac{\partial{L}}{\partial{b_1}}=(y-r)^{2} * (1-y+r) * w_3 * o_2 * (1-o_2) * o_1 * (1-o_1)\]</span></p><p>计算损失函数<span class="math inline">\(L\)</span>关于网络权重的梯度后，网络权重的变化为：</p><p><span class="math display">\[\bigtriangleup W = - \eta * \frac{\partial{L}}{\partial{W}}\]</span></p><p>其中， <span class="math inline">\(W\)</span>是网络中的权重参数，一般只通过学习率来调节网络训练的快慢，是不够的。会加入动态变化量，以加快学习过程。所以：</p><p><span class="math display">\[\bigtriangleup W=-\eta * \frac{\partial{L}}{\partial{W}} + \alpha * \frac{\partial{L}}{\partial{W}}\]</span></p><p>其中，<span class="math inline">\(\alpha\)</span>表示动态变化项，是一个常数。</p>]]></content>
    
    
    <categories>
      
      <category>DEEP LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gradient descent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无迹卡尔曼滤波</title>
    <link href="/2020/01/21/MachineLearning/Unscented-Kalman-Filter/"/>
    <url>/2020/01/21/MachineLearning/Unscented-Kalman-Filter/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近读了一篇文献，里面用到了无迹卡尔曼滤波(Unscented Kalman Filter)。这里写一下我对这种方法的理解。卡尔曼滤波的理解部分可以参考</p><h2 id="我的一点点理解">我的一点点理解</h2><p>无迹卡尔曼滤波是对卡尔曼滤波的一种改进。这种改进主要是针对非线性的信号。因为在卡尔曼滤波中，预测模型以及测量空间对应的转换矩阵都是都是线性转换。但是在面对非线性信号时，会出现无法拟合的情况。所以就有了无极卡尔曼滤波。这种方法的主要改进在于，不再用线性的模型去计算预测模型以及转换矩阵，而是通过采样和计算均值方法的方式，去估计样本的方差和均值。</p><h2 id="计算过程">计算过程</h2><p>无迹卡尔曼滤波的计算方式和卡尔曼滤波比较类似，只是讲线性转换模型换成了采样的方式。具体的原理推导比较复杂，所以这里只写一下无迹卡尔曼滤波的计算过程：</p><p>无迹卡尔曼的计算步骤和卡尔曼滤波基本是一致的，只是对其中的一些步骤进行了修改，首先，我们看一下Kalman Filter的计算过程：</p><ol type="1"><li><p>建立编码模型和转换模型， 假设观测变量是<span class="math inline">\(z\)</span>， 测量变量是<span class="math inline">\(x\)</span>， 那么首先我们假设：</p><ol type="1"><li>当前时刻的测量变量是可以根据上一时刻的测量变量估计： <span class="math display">\[x_{t} = Fx_{t-1} + w_t, (w_t -N(0, Q))\]</span></li></ol></li><li><p>当前时刻的观测变量可以根据测量变量估计： <span class="math display">\[   z_t = Hx_t + r_t, (r_t - N(0, R))   \]</span></p></li><li><p>根据以上的编码模型和转换模型，Kalman Filter的计算流程如下：</p><ol type="1"><li>首先，根据已知的模型，以及上一时刻的卡尔曼估计值，计算当前时刻的模型预测值</li></ol><p><span class="math display">\[x_t'=Fx_{t-1}\]</span></p><ol start="2" type="1"><li>根据当前的模型预测值，计算对应的协方差</li></ol><p><span class="math display">\[P(x_t|x_t')=FP(x_t|X_t)F^T\]</span></p><ol start="3" type="1"><li>根据当前的协方差和测量空间的转换矩阵，计算当前时刻的卡尔曼增益</li></ol><p><span class="math display">\[K_t=P(x_t|x_t')H^T(HP(x_t|x_t')H^T+R)^{-1}\]</span></p><ol start="4" type="1"><li>根据卡尔曼增益和测量值，计算当前时刻的卡尔曼估计值</li></ol><p><span class="math display">\[x_t=x_t'+K_t(z_t-Hx_t')\]</span></p><ol start="5" type="1"><li>计算了当前时刻的卡尔曼估计值之后，还需要计算当前的估计值和真实值的协方差矩阵，方便下一次计算</li></ol><p><span class="math display">\[P(x_t|X_t)=(I-HK_t)P(x_t|x_t')\]</span></p><p>作为线性的解码器，Kalman Filter确实能找到观测变量和测量变量之间的关系，并用观测变量去纠正当前测量变量中的误差。但是涉及到非线性关系的时候，Kalman Filter的线性假设就不成立了。这时有两种优化的方法：</p><ol type="1"><li>如果已知这种非线性关系的公式，例如加速度和位置的关系等，那么可以把上述转换模型和观测模型换成已知的非线性模型，增加解码准确率。这种方法就是<strong>扩展卡尔曼滤波(Extend Kalman Filter)</strong>。这种方法的优点在于拟合更加准确，但是缺点也很明显。首先是计算量增加，如果非线性拟合涉及很复杂的模型，那么计算量比Kalman Filter增加很多。然后是非线性模型，并不是任何时候，这种模型都是已知的，如果不是已知的，那就需要进行非线性拟合，找到最合适的拟合模型，例如指数模型，高阶模型等，再次增加计算量。</li><li>如果不知道这种非线性关系的公式，那么我们可以进行非线性拟合或者直接假设一个公式。但是我们观察Kalman Filter的计算过程，整个估计过程中，用到了当前时刻的值，以及协方差。而这两个量，我们是能通过采样的方式得到的，即，可以不需要直接计算非线性模型的协方差矩阵，直接通过采样估计，类似蒙特卡洛的方法。但是采样的计算量会更大，因为需要大样本才能得到准确的估计。目前有另外一种办法，能够用很少的采样点(几个)就得到准确的估计，这种方法是无迹变换(Unscented Transform)，结合到Kalman Filter中，就是<strong>无迹卡尔曼滤波(Unscented Kalman Filter)</strong></li></ol><p>所以无迹卡尔曼滤波的主要流程如下：</p><ol type="1"><li>计算转换模型和编码模型<ol type="1"><li><p>建立转换模型，可以是非线性也可以是线性，这里用线性模型： <span class="math display">\[x_{t} = Fx_{t-1} + w_t, (w_t -N(0, Q))\]</span></p></li><li><p>建立编码模型，也可以是线性或非线性模型： <span class="math display">\[z_t = Hx_t + r_t, (r_t - N(0, R))\]</span></p></li></ol></li></ol></li><li><p>根据上述模型和训练集数据，用最小二乘法或其他的拟合方法，得到模型参数，然后开始无迹卡尔曼的预测和更新阶段</p><ol type="1"><li><p>根据模型预测<span class="math inline">\(x_{t}\)</span> <span class="math display">\[   x_t'=Fx_{t-1}   \]</span></p></li><li><p>预测<span class="math inline">\(x_{t}\)</span>的协方差 <span class="math display">\[   P(x_t|x_t')=FP(x_t|X_t)F^T + Q   \]</span></p></li><li><p>用采样点估计当前协方差矩阵，先采样<span class="math inline">\(2d+1\)</span>个点，并保证中心点的值为<span class="math inline">\(x_t'\)</span> <span class="math display">\[   X_0 = x_t'   \]</span></p><p><span class="math display">\[   X_i = x_t' + (\sqrt{(d + k)P(x_t|x_t')})_{i}, i = 1, ..., d\]</span></p><p><span class="math display">\[   X_i = x_t' - (\sqrt{(d + k)P(x_t|x_t')})_{i}, i = d + 1, ..., 2d\]</span></p></li><li><p>计算采样点的权重值 <span class="math display">\[   w_0= \frac{k}{d+k}, w_i = \frac{1}{2d+k}, i = 1, ... 2d   \]</span></p></li><li><p>根据转换矩阵，采样点，计算观测值和测量值的关系 <span class="math display">\[Z_i = h(X_i), i = 0, ...2d\]</span></p><p><span class="math display">\[z_t = \sum_{i = 0, ...2d}{w_{i}Z_{i}}\]</span></p></li><li><p>根据采样点估计的观测值，计算观测值<span class="math inline">\(z\)</span>的方差，以及观测值<span class="math inline">\(z\)</span>和测量值<span class="math inline">\(x\)</span>的协方差 <span class="math display">\[P_{zz, t} = w_{0}(Z_{0}-z_{t})(Z_{0}-z_{t})^T + (\sum_{i=1, ...,2d}{w_{i}(Z_{i}-Z_{0})(Z_{i}-z_{0})^T}) + R\]</span></p><p><span class="math display">\[P_{xz, t} = w_{0}(Z_{0}-z_{t})(Z_{0}-z_{t})^T + (\sum_{i=1, ..., 2d}{w_{i}(X_{i}-X_{0})(Z_{i}-Z{0})^T})\]</span></p></li><li><p>根据计算的协方差，可以计算Kalman增益 <span class="math display">\[K = P_{xz, t}P_{zz, t}^{-1}\]</span></p></li><li><p>用Kalman增益计算最有估计值 <span class="math display">\[x_t = x_t' + K_t(h(x_t')-z_t)\]</span></p><p><span class="math display">\[P(x_t|X_t) = P(x_t|x_t')-P_{xz, t}(P_{zz, t}^{-1})^TP_{xz, t}^{T}\]</span></p><p>以上就是无迹卡尔曼滤波的主要步骤，后续会附上代码链接</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>MACHINE LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UKF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>样本方差和统计方差</title>
    <link href="/2020/01/21/Algorithm/Two-Types-of-Variance/"/>
    <url>/2020/01/21/Algorithm/Two-Types-of-Variance/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们知道，统计学上方差的计算公式如下：</p><p><span class="math display">\[ \sigma^2=\frac{\sum_{i=1}^{n}(x_i-\mu)}{n}\]</span></p><p>这是统计学中方差的定义，已知条件有总体的均值<span class="math inline">\(\mu\)</span>，以及总体个数<span class="math inline">\(n\)</span>，公式的另一种写法为： <span class="math display">\[\sigma^2=E[(x-\mu)^2]=\sum{(x-\mu)^2}p(x)\]</span></p><p>其中<span class="math inline">\(p(x)\)</span>是<span class="math inline">\(x\)</span>出现的概率，所以这个公式只对于离散变量有效。 那么，如果总体量很大，不能做到全部采样，那么就需要用样本来估计总体，假设从总体为<span class="math inline">\(N\)</span>的总数中抽取<span class="math inline">\(n\)</span>个样本，其中<span class="math inline">\((N&gt;&gt;n)\)</span>，采样值为<span class="math inline">\(x_1,x_2,...,x_n\)</span> 样本均值为：</p><p><span class="math display">\[\bar{x}=\frac{\sum_{i=1}^{n}{x_i}}{n}\]</span></p><p>样本的方差为：</p><p><span class="math display">\[ S^2=\frac{\sum_{i=1}^{n}(x_i-\bar{x})}{n}\]</span></p><p>但是样本的方差和总体的方差是有差别的，计算样本方差的期望值，来估计样本方差和实际方差<span class="math inline">\(\sigma^2\)</span>之间差了多少：</p><p><span class="math display">\[ E[S^2]=E[\frac{\sum_{i=1}^{n}(x_i-\bar{x})}{n}]\]</span></p><p><span class="math display">\[=E[\frac{1}{n}\sum_{i=1}^{n}{((x_i-\mu)-(\bar{x}-\mu))^2}]\]</span></p><p><span class="math display">\[=E[\frac{1}{n}\sum_{i=1}^{n}{((x_i-\mu)^2-2(x_i-\mu)(\bar{x}-\mu)+(\bar{x}-\mu)^2)}]\]</span></p><p><span class="math display">\[=E[\frac{1}{n}\sum_{i=1}^{n}{(x_i-\mu)^2}-\frac{2}{n}(\bar{x}-\mu)\sum_{i=1}^{n}{(x_i-\mu)}+(\bar{x}-\mu)^2]\]</span></p><p>其中</p><p><span class="math inline">\(\sum_{i=1}^{n}{(x_i-\mu)}\)</span> <span class="math inline">\(=\sum_{i=1}^{n}{x_i}-\sum_{i=1}^{n}{\mu}\)</span> <span class="math inline">\(=n(\bar{x}-\mu)\)</span></p><p>所以</p><p><span class="math inline">\(=E[\frac{1}{n}\sum_{i=1}^{n}{(x_i-\mu)^2}-\frac{2}{n}(\bar{x}-\mu)\sum_{i=1}^{n}{(x_i-\mu)}+(\bar{x}-\mu)^2]\)</span> <span class="math inline">\(=E[\frac{1}{n}\sum_{i=1}^{n}{(x_i-\mu)^2}-2(\bar{x}-\mu)^2+(\bar{x}-\mu)^2]\)</span> <span class="math inline">\(=\sigma^2-E[(\bar{x}-\mu)^2]\)</span></p><p>（这里<span class="math inline">\(\sigma^2\)</span>是因为样本方差的期望值是总体方差）</p><p><span class="math inline">\(E[(\bar{x}-\mu)^2]\)</span> <span class="math inline">\(=E(\bar{x}-E[\bar{x}])^2\)</span> <span class="math inline">\(=var(\bar{x})\)</span> <span class="math inline">\(=\frac{1}{n^2}var(\sum_{i=1}^{n}{x_i})\)</span> <span class="math inline">\(=\frac{1}{n^2}\sum_{i=1}^{n}{var(x_i)}\)</span> <span class="math inline">\(=\frac{n\sigma^2}{n^2}\)</span> <span class="math inline">\(=\frac{\sigma^2}{n}\)</span></p><p>根据上面推导的式子，有以下计算：</p><p><span class="math inline">\(\sigma^2-E[(\bar{x}-\mu)^2]\)</span> <span class="math inline">\(=\sigma^2-\frac{\sigma^2}{n}\)</span> <span class="math inline">\(=\frac{n-1}{n}\sigma^2\)</span></p><p>也就是说，样本估计的方差是总体方差的<span class="math inline">\(\frac{n-1}{n}\)</span>倍，即所谓的有偏估计。要转换成无偏估计，只需要乘以倍数就可以了</p><p><span class="math display">\[\frac{n}{n-1}S^2=\frac{n}{n-1}\frac{\sum_{i=1}^{n}(x_i-\bar{x})}{n}=\frac{\sum_{i=1}^{n}(x_i-\bar{x})}{n-1}\]</span></p><p>这即是所谓的无偏估计。 当然，还有一种比较直接的解释，由于是求统计样本中的方差，所以在求解统计样本均值时，已经用掉了一个自由度的值，所以求方差时，其实有用的值会少一个。例如在只有一个样本时，这时求方差是没有意义的。不过在概率论中，求此时的方差是有意义的，因为已经知道了总体的概率分布，所以即使只有一个样本，总体的分布是不变的。其中区别就在于统计样本只是用于估计。</p>]]></content>
    
    
    <categories>
      
      <category>ALGORITHMS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>statistics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Population Vector Algorithm</title>
    <link href="/2020/01/21/MachineLearning/Population-Vector-Algorithm/"/>
    <url>/2020/01/21/MachineLearning/Population-Vector-Algorithm/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="算法推导">算法推导：</h2><ol type="1"><li><p>信号预处理 这里的算法推导主要针对神经元集群解码，因为PVA的主要应用还是在神经元解码中 首先，采集到的spike信号是以发放次数的方式存储的，这里需要先转换成发放率的形式，即： <span class="math display">\[fr[n]=\frac{spk[n]}{\Delta t} \tag{1}\]</span></p></li><li><p>其中，<span class="math inline">\(fr[n]\)</span>表示<span class="math inline">\(n\)</span>时刻神经元的发放率，<span class="math inline">\(\Delta t\)</span>表示一个bin的长度，通常的取值为20ms，30ms，50ms，1000ms等。<span class="math inline">\(spk[n]\)</span>表示神经元在第<span class="math inline">\(n\)</span>个bin中发放的次数。 然后，对发放率做一个FIR滤波，主要目的是平滑发放率曲线，计算公式如下：</p></li></ol><p><span class="math display">\[s[n]=\sum_{i=1}^{W-1}{fr[n-i]h[i]} \tag{2}\]</span></p><p>其中，<span class="math inline">\(h[i]\)</span>表示滤波器的卷积函数，可以根据需求选取，<span class="math inline">\(W\)</span>表示滤波器的阶数，可以根据实际需要选择。</p><p>PVA算法原理 PVA算法的提出，主要是根据实验中观察到的现象。在猴子将手臂移动向不同的方向时，不同的神经元发放的率产生了变化，我们由此假设，神经元的发放率跟运动方向是有关系的，所以我们想到，用余弦曲线的方式，去拟合神经元的发放率与运动方向之间的关系。首先，我们假设每个神经元都有一个自己的偏好方向<span class="math inline">\(\theta_{PD}\)</span>，假设此时，猴子手臂的运动方向为<span class="math inline">\(\theta\)</span>，那么此时神经元的发放率为： <span class="math display">\[f=m*cos(\theta-\theta_{PD})+b_0 \tag{3}\]</span></p><p>其中，<span class="math inline">\(m\)</span>为表征神经元活泼性的参数，即有的神经元可能表征的偏好方向一样，但是在偏好方向上的发放率变化是不一样的。<span class="math inline">\(b_0\)</span>表示神经元的基础发放率，即在静息状态下的基础发放率。<span class="math inline">\(f\)</span>表示的是神经元在猴子手臂朝向<span class="math inline">\(\theta\)</span>方向运动时的发放率，注意这里是发放率不是spike count，虽然两者可以通过bin转换，但是公式推导的时候两者还是不一样的。 公式<span class="math inline">\((3)\)</span>表示了单个神经元的发放与运动的关系。猴子大脑M1区域的神经元是很多的，对不同的方向肯定有不同的偏好性。那么如何处理这种不一致性呢，我们的方法是用矢量求和的形式，得出一个此时最可能的运动方向。即：</p><p><span class="math display">\[\vec{u}=\frac{1}{N}  \sum_{i=1}^{n}{m*cos{\theta_{PD}}} \tag{4}\]</span></p><p>这里<span class="math inline">\(\vec{u}\)</span>表示神经元此时解码出来的运动方向，这里也能部分表征运动速度，但是速度的大小也与实际的运动距离有关，所以，运动速度的计算如下：</p><p><span class="math display">\[v=k*\vec{u}+\sigma \tag{5}\]</span></p><p>这里<span class="math inline">\(k\)</span>表示实际速度与计算得出的速度的比例，<span class="math inline">\(\sigma\)</span>表示实际速度与解码得到的速度之间的误差，以上就是PVA算法的主要原理 3. 参数计算 那么，现在的问题在于，如何计算PVA算法中的几个参数，这里我们用最小二乘法的方式，求最小误差情况下的参数<span class="math inline">\(b_0,m,\theta_{PD}\)</span>，我们将公式<span class="math inline">\((3)\)</span>换一种写法，即：</p><p><span class="math display">\[f = b_0 + b_1 * cos \theta + b_2 * sin \theta \tag{6}\]</span></p><p>再考虑<span class="math inline">\(cos{\theta}\)</span>和<span class="math inline">\(sin{\theta}\)</span>这两个量，对应在速度中，可以表示为归一化过后的<span class="math inline">\(v_x\)</span>和<span class="math inline">\(v_y\)</span>，只要在<span class="math inline">\([-1,1]\)</span>这个区间内所以，将公式<span class="math inline">\((6)\)</span>写成：</p><p><span class="math display">\[f = b_0 + b_1 * v_x + b_2 * v_y \tag{7}\]</span></p><p>用最小二乘法计算，误差为：</p><p><span class="math display">\[\epsilon = \sum_{ i=1 }^{n}{(b_0 + b_1 * v_x + b_2 * v_y - f)^2} \tag{8}\]</span></p><p>最终计算结果根据要推导一下，这里先暂时不写，回去再补充 所以，极值在偏导数为<span class="math inline">\(0\)</span>的地方取得，即： <span class="math display">\[\frac{\partial{\epsilon}}{\partial{b_0}}=0 \tag{9}\]</span> <span class="math display">\[\frac{\partial{\epsilon}}{\partial{b_1}}=0 \tag{10}\]</span> <span class="math display">\[\frac{\partial{\epsilon}}{\partial{b_2}}=0 \tag{11}\]</span></p><p>解上述方程，可以得到<span class="math inline">\(b_0,b_1,b_2\)</span>的值，即：</p><p><span class="math display">\[\beta=(A^T*A)^{-1}A^TB \tag{12}\]</span></p><p>其中，<span class="math inline">\(\beta=(b_0,b_1,b_2)\)</span>，<span class="math inline">\(A\)</span>为运动信息矩阵，<span class="math inline">\(B\)</span>为神经信号矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>MACHINE LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隐马尔科夫模型</title>
    <link href="/2020/01/21/MachineLearning/Hidden-Markov-Model/"/>
    <url>/2020/01/21/MachineLearning/Hidden-Markov-Model/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景">背景</h2><p>隐马尔可夫模型(Hidden Markov Model)是一种常用的统计模型。应用也比较广泛，在时序问题，以及语音识别等问题上有广泛的应用。下面简单介绍一下隐马尔可夫模型。</p><p>隐马尔可夫模型是在马尔可夫过程的基础上，加入了隐含状态后的一种结构。这里首先介绍一下什么是马尔可夫过程(Markov Process)</p><p>在一个随机过程中，有一个状态变量<span class="math inline">\(I\)</span>，其下一时刻的状态之和之前的状态有关。例如布朗运动，粒子的下一时刻状态之和之前时刻的状态有关。而<span class="math inline">\(I\)</span>变化的过程，也就是马尔科夫链。这个约束，也就是马尔可夫假设。</p><p><img src="/img/HiddenMarkovModel/1.jpg"></p><p>在马尔可夫过程中，模型还是很复杂，我们还可以加约束来让模型变得简单一点。我们可以假设，状态变量<span class="math inline">\(I\)</span>的下一时刻状态只和上一时刻的状态有关。这样就得到了齐次马尔可夫模型。即：</p><p><span class="math display">\[p(I_t|I_{t-1}, I_{t-2}, ..., I_{0}) = p(I_t|I_{t-1}), t=1, 2, ..., T\]</span></p><p>我们可以看出，马尔可夫模型的描述，只针对某一个变量而言。但是实际生活中，很多变量之间都是相关的。例如你的运动是由肌肉的收缩和舒张来完成的。但是在观察者看来，你只是完成了一个简单的运动。其中，你的运动状态就是观测到的变化量，而肌肉的状态就是隐藏的状态。所以HMM模型的结构如下图所示：</p><p><img src="/img/HiddenMarkovModel/2.jpg"></p><p>和马尔可夫过程一样，HMM也有一些约束条件。首先，HMM要满足马尔可夫假设且满足齐次马尔可夫模型，即：</p><p><span class="math display">\[p(I_t|I_{t-1}, o_{t-1}, ..., I_{0}, o_{0}) = p(I_t|I_{t-1}), t=1, 2, ..., T\]</span></p><p>然后是观测独立性假设，也就是说任意时刻的观测值只依赖于当前时刻的马尔可夫链的状态<span class="math inline">\(i_t\)</span>， 即：</p><p><span class="math display">\[p(o_t|I_t, I_{t-1}, o_{t-1}, ..., I_{0}, o_{0}) = p(o_t|I_t), t=1, 2, ..., T\]</span></p><h2 id="原理">原理</h2><p>HMM的结构如上图所示，其中<span class="math inline">\(I\)</span>是状态变量，<span class="math inline">\(O\)</span>是观测变量。假设<span class="math inline">\(Q\)</span>是所有可能的状态的集合，<span class="math inline">\(V\)</span>是所有可能的观测的集合。</p><p><span class="math display">\[Q = \{ q_1,q_2,...,q_N \}\]</span></p><p><span class="math display">\[V = \{v_1,v_2,...,v_M \}\]</span></p><p>即可能的状态有N种， 可能的观测值有M种，两者不一定会相等。那么在一次试验中，观测到的值为<span class="math inline">\(O\)</span>，每个观测值会唯一对应一个状态值，因为试验已经结束了，假设状态序列为<span class="math inline">\(I\)</span>，那么<span class="math inline">\(O\)</span>和<span class="math inline">\(I\)</span>的长度一样，假设为T，那么： <span class="math display">\[O = \{ O_1,O_2,...,O_T \}\]</span></p><p><span class="math display">\[I = \{ I_1,I_2,...,I_T \}\]</span></p><p>在<span class="math inline">\(t\)</span>时刻会有一个状态值，那么下一个时刻的状态值会与上一时刻相关，当然也可以是不相关的，由此给出状态矩阵<span class="math inline">\(A\)</span>的定义：</p><p><span class="math display">\[A=[a_{ij}]\]</span></p><p><span class="math inline">\(a_{ij}\)</span>表示当前时刻<span class="math inline">\(t\)</span>状态为<span class="math inline">\(q_i\)</span>的情况下，下一时刻的状态为<span class="math inline">\(q_j\)</span>的概率，这里<span class="math inline">\(i,j=1,2,...N\)</span>，用数学形式表示，即： <span class="math display">\[a_{ij}=P(I_{t+1}=q_j | I_t=q_i)\]</span></p><p>有了状态转移矩阵后，我们并不能直接估计下一时刻的状态，因为状态在整个试验过程中是隐藏的，试验中只能得到观测值的相关信息，所以还要有观测值和状态值之间的转换矩阵，即当观测到某个值时，其对应于各个状态的概率分别是多少。假设观测概率矩阵是<span class="math inline">\(B\)</span>，给出<span class="math inline">\(B\)</span>的定义：</p><p><span class="math display">\[B=[b_{jk}]\]</span></p><p><span class="math inline">\(b_{jk}\)</span>表示当前时刻<span class="math inline">\(t\)</span>状态值为<span class="math inline">\(q_j\)</span>的情况下，观测值为<span class="math inline">\(v_k\)</span>的概率。所以有<span class="math inline">\(k=1,2,...M\)</span>，<span class="math inline">\(j=1,2,...,N\)</span>，用数学形式表示，即：</p><p><span class="math display">\[b_{jk}=P(o_t=v_k | i_t=q_j)\]</span></p><p>确定了观测值和状态值之间的转换概率，当前时刻和下一时刻之间的状态转换概率，那么我们还需要确定可能的观测值在试验刚开始时被选中的概率，假设为<span class="math inline">\(\pi\)</span>，给出<span class="math inline">\(\pi\)</span>的定义：</p><p><span class="math display">\[\pi=[\pi_{i}]\]</span></p><p>其中<span class="math inline">\(\pi_{i}\)</span>表示观测值<span class="math inline">\(q_i\)</span>在刚开始被选中的概率，那么，<span class="math inline">\(i=1,2,...,N\)</span>，用数学的形式表示，即：</p><p><span class="math display">\[\pi_i=P(I_1=q_i)\]</span></p><p>到这里，整个HMM模型中的主要参数已经全部介绍了，由介绍可知，根据<span class="math inline">\(\pi,A,B\)</span>可以让一个HMM模型顺利工作。可以求出在任意状态序列对应的概率<span class="math inline">\(P(O|\lambda)\)</span>。所以，我们也用这些参数来表示一个HMM模型，即： <span class="math display">\[\lambda=\{ A,B,\pi \}\]</span> 。</p><h2 id="常见问题">常见问题</h2><p>以上介绍了HMM的基本概念，在实际应用中，主要有以下几个基本问题：</p><ol type="1"><li>已知模型<span class="math inline">\(\lambda\)</span>以及观测序列<span class="math inline">\(O\)</span>，计算在这种模型下出现这种观测序列的概率<span class="math inline">\(P(O|\lambda)\)</span></li><li>已知观测序列<span class="math inline">\(O\)</span>，但是不知道模型<span class="math inline">\(\lambda\)</span>，计算模型<span class="math inline">\(\lambda\)</span>，使得当前观测序列产生的概率<span class="math inline">\(P(O|\lambda)\)</span>最大</li><li>给定模型<span class="math inline">\(\lambda\)</span>和观测序列<span class="math inline">\(O\)</span>，计算最有可能产生这一观测序列的状态序列<span class="math inline">\(I\)</span>，即使得<span class="math inline">\(P(I|O,\lambda)最大的\)</span><span class="math inline">\(I\)</span></li></ol><p>以上就是最常见的HMM问题，主要涉及到模型中各个参数计算的问题。</p><p>在问题１中，我们需要计算观测序列出现的概率，主要可以用来判断出现的这一观测序列是否常见，如果计算得到的概率很低，但是在实际观测中却经常出现，那么就需要检查系统中是否出现了外部干扰。</p><p>在问题2中，我们需要计算模型的参数。主要是用于模型的学习和自适应参数调整的问题。模型是不确定的，但是根据给定的观测序列，我们需要找到一个最合适的模型，来保证出现这一观测序列的概率最大。有点类似回归求最优解或者神经网络拟合的思想。</p><p>在问题3中，我们需要通过观测序列和模型，来估计隐藏状态。这个主要适用于一些解码问题。通过观测值求解隐藏值。</p><p>针对以上的问题，分别有对应的解决办法。下面会介绍最常见的一些解法。当然，由于ＨＭＭ中，观测变量和隐藏状态可能的取值是有限的。所以其实用穷举法也可以算，只是计算量会很大。</p><h2 id="解决办法">解决办法</h2><h3 id="问题1">问题1</h3><p>已知模型和观测序列，要计算出现这种观测序列的概率<span class="math inline">\(P(O|\lambda)\)</span></p><p>这个问题有两种解法，前向和后向算法。两种方法比较类似。</p><ol type="1"><li>前向算法</li></ol><p>首先，我们定义一个概率：</p><p><span class="math display">\[p_t(i) = P(o_1, o_2, ..., o_t, I_t=q_i)\]</span></p><p><span class="math inline">\(p_t(i)\)</span>表示观测序列为<span class="math inline">\({o_0, o_1, ...,o_t}\)</span>，同时<span class="math inline">\(I_t=q_i\)</span>的概率。所以我们有以下递推公式：</p><p><span class="math display">\[p_{t}(i) = (\sum_{j=1}^{N}p_{t-1}(j)a_{ji})b_{ik}\]</span></p><p>同时，有<span class="math inline">\(o_{t}=v_{k}\)</span>。在上面的公式中，<span class="math inline">\(\sum_{j=0}^{N}p_{t-1}(j)a_{ji}\)</span>表示前<span class="math inline">\(t-1\)</span>个输出为<span class="math inline">\({o_1, o_2, ..., o_{t-1}}\)</span>，且第<span class="math inline">\(t\)</span>个隐藏状态为<span class="math inline">\(q_i\)</span>的概率。因为<span class="math inline">\(t-1\)</span>时刻的状态是任何值都可以，只需要乘以对应的转移概率，就可以计算出<span class="math inline">\(t\)</span>时刻状态为<span class="math inline">\(q_i\)</span>的概率了。</p><p>然后在初始状态时，有：</p><p><span class="math display">\[p_1(i) = \pi_ib_{ik}, o_1=v_k\]</span></p><p>所以最终得到的概率为：</p><p><span class="math display">\[P(O|\lambda) = \sum_{i=1}^{N}p_T(i)\]</span></p><p>也就是说，在<span class="math inline">\(T\)</span>时刻，观测序列为<span class="math inline">\({o_1, o_2, ..., o_T}\)</span>，且模型为<span class="math inline">\(\lambda\)</span>的概率为观测序列为<span class="math inline">\({o_1, o_2, ..., o_T}\)</span>且<span class="math inline">\(T\)</span>时刻状态值为<span class="math inline">\({q_1, q_2, ..., q_N}\)</span>的所有值的和。</p><ol start="2" type="1"><li>后向算法</li></ol><p>后向算法和前向算法比较类似，都是通过递推的方式逐步计算观测序列的概率。不同的地方是，后向算法是从后往前算，前向算法是从前往后算。</p><p>假设观测序列的长度为<span class="math inline">\(T\)</span>，并定义从<span class="math inline">\(t+1\)</span>时刻到<span class="math inline">\(T\)</span>时刻的序列为<span class="math inline">\({o_{t+1}, o_{t+2}, ..., o_T}\)</span>，且<span class="math inline">\(t\)</span>时刻的隐藏状态为<span class="math inline">\(q_i\)</span>的概率为：</p><p><span class="math display">\[p_t(i) = P(o_{t+1}, o_{t+2}, ..., o_T, I_t=q_i|\lambda)\]</span></p><p>对于后向算法，初始状态应该是<span class="math inline">\(p_T(i)\)</span>，表示的是观测序列为<span class="math inline">\({o_{T+1}}\)</span>时，且隐藏状态为<span class="math inline">\(q_i\)</span>的概率，但是因为已经知道了<span class="math inline">\(o_T\)</span>的状态了，且<span class="math inline">\(o_{T+1}\)</span>并没有发生，所以这里其实给任意值都可以。这个值其实主要表示的是<span class="math inline">\(T+1\)</span>时刻和<span class="math inline">\(T\)</span>时刻的关系，但是这个关系并不知道，所以给任意值都是可以的。表示这个关系可以是任意的。</p><p>然后和前向算法类似，我们可以计算后向的递推公式：</p><p><span class="math display">\[p_t(i) = \sum_{j=1}^{N}a_{ij}b_{jk}p_{t+1}(j)\]</span></p><p>其中有，<span class="math inline">\(o_{t+1} = v_k\)</span></p><p><span class="math inline">\(\sum_{j=1}^{N}a_{ij}p_{t+1}(j)\)</span>表示<span class="math inline">\(t+2\)</span>时刻状态为<span class="math inline">\(q_j\)</span>且<span class="math inline">\(t\)</span>时刻的状态为<span class="math inline">\(q_i\)</span>的所有可能的<span class="math inline">\(t+2\)</span>时刻的值的和，所以<span class="math inline">\(a_{ij}b_{jk}p_{t+1}(j)\)</span>表示的是，<span class="math inline">\(t+1\)</span>时刻的观测值为<span class="math inline">\(o_{t+1}\)</span>，也就是<span class="math inline">\(v_k\)</span>，同时<span class="math inline">\(t+1\)</span>时刻的状态值为<span class="math inline">\(q_j\)</span>的概率。求和之后就是，<span class="math inline">\(t+1\)</span>到<span class="math inline">\(T\)</span>时刻的观测值为<span class="math inline">\({o_{t+1}, o_{t+2}, ..., o_{T}}\)</span>，且$</p><p>t<span class="math inline">\(时刻的隐藏状态为\)</span><span class="math inline">\(q_i\)</span>的概率。也就是<span class="math inline">\(p_t(i)\)</span>。</p><p>所以可以得到，最终计算的概率为：</p><p><span class="math display">\[P(O|\lambda) = \sum_{i=1}^{N}\pi_{i}b_i(o_1)p_1(i)\]</span></p><p>其中，<span class="math inline">\(p_1(i)\)</span>表示的是观测序列为<span class="math inline">\({o_2, o_3, ..., o_T}\)</span>，$ b_i(o_1)p_1(i)<span class="math inline">\(表示观测序列为\)</span>{o_1, o_2, ..., o_T}<span class="math inline">\(。所以\)</span>_ib_i(o_i)p_1(i)<span class="math inline">\(表示观测序列为\)</span>o_1, o_2, ..., o_T<span class="math inline">\(, 且\)</span>I_1=q_i<span class="math inline">\(的概率，对所有的\)</span>I_1={q_1, q_2, ..., q_N}<span class="math inline">\(求和，就是观测序列为\)</span>{o_1, o_2, ..., o_N}$的概率</p><p>以上就是两种计算观测序列概率的算法。主要的思想都是通过递推计算。</p><h3 id="问题2">问题2</h3><p>已知观测序列<span class="math inline">\(O\)</span>， 计算使得<span class="math inline">\(P(O|\lambda)\)</span>最大的模型参数<span class="math inline">\(\lambda\)</span></p><p>这个问题有点类似于回归问题中的拉格朗日极值问题，但是由于涉及到隐藏变量的极大似然估计，所以这里并不能用求导的方法来计算。广泛使用的一种计算方法是EM(Expectation Maximum)算法。关于EM算法，会在后续的文章中介绍，这里暂且不写。</p><h3 id="问题3">问题3</h3><p>已知观测序列<span class="math inline">\(O\)</span>和模型参数<span class="math inline">\(\lambda\)</span>，求可能产生这一观测序列的隐藏状态<span class="math inline">\(I\)</span>, 使得<span class="math inline">\(P(I|\lambda)\)</span>最大</p><p>这个问题类似于常见的解码问题。对于HMM模型下的解码问题，一般是用动态规划的方法来求解的。因为这样计算量会降低。常用的HMM解码问题的解决办法是维特比算法(Viterbi Algorithm)。这个也会在后续的文章中介绍。这里暂且不写。</p>]]></content>
    
    
    <categories>
      
      <category>MACHINE LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主成分分析</title>
    <link href="/2020/01/21/MachineLearning/Principle-Component-Analysis/"/>
    <url>/2020/01/21/MachineLearning/Principle-Component-Analysis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写一下算法的基本原理和实现</p><h2 id="pcaprinciple-component-analysis">PCA(Principle Component Analysis)</h2><p>PCA是最常见的一种降维算法，其核心思想是数据从高维到低维的投影，使其方差最大化。这个也很好理解，比如，这里我们假设有3组数据<span class="math inline">\(a_1,a_2,a_3\)</span>，然后第1组的值可以用第2组数据的函数表示，比如<span class="math inline">\(a_2=2*a_1\)</span>。如果以<span class="math inline">\(a_1,a_2,a_3\)</span>为坐标画出对应的图像，那么在3维空间中就对应了一个平面，以这个平面的坐标轴为参数，此时看到的就是二维数据，相当于降维了。</p><p>插图（参考文献） <img src="/img/dimensionality-reduction/1.png" alt="dimensionality reduction-1"></p><p>参考文献：</p><p>假设我们有<span class="math inline">\(m\)</span>组<span class="math inline">\(n\)</span>维数据，希望能降维到<span class="math inline">\(k\)</span>维(<span class="math inline">\(k&lt;d\)</span>)，PCA的计算过程如下：</p><p>数据零均值化</p><p>求协方差矩阵</p><p>求协方差矩阵对应的特征值和特征向量</p><p>将特征向量按特征值大小取前<span class="math inline">\(k\)</span>行从上向下组成矩阵</p><p>将得到的矩阵乘以<span class="math inline">\(X\)</span>就能得到降维后的数据</p><p>这里数据零均值化主要是为了方便后面的计算（测试一下不做这一步有什么问题）</p><p>然后求协方差矩阵，之所以选择协方差矩阵，是因为协方差能很好地反应不同维度之间的差异，假设数据集为<span class="math inline">\(X={x_1,x_2,...,x_m}\in R^{m*n}\)</span>，</p><p>那么协方差矩阵<span class="math inline">\(Cov\)</span>的定义为</p><p><span class="math display">\[CovX(i,j)=\sum_{} x_ix_j\frac{1}{m}\]</span></p><p>因为之前做过零均值化，所以这里<span class="math inline">\(x_i\)</span>和<span class="math inline">\(x_j\)</span>的均值都是0。 可以看出，协方差矩阵非对角线上的值表示了不同维度上数据之间的差异，对角线上的数据表示了每个维度的数据分布的差异。即在所有组数据中，每个维度上的变化大小的评价。对于协方差矩阵，当<span class="math inline">\(CovX(i,j)=0\)</span>时，说明第<span class="math inline">\(i\)</span>维和第<span class="math inline">\(j\)</span>维的数据是相互独立的，所以，PCA优化的目标在于，尽可能让不同维度之间的协方差为0，而尽可能增大维度自身的方差。 关于求协方差矩阵的特征值，可以理解为将一个特征向量在<span class="math inline">\(n\)</span>维空间中进行旋转和拉伸变换，使之与特征向量自己在同一直线上并成一定的比例，那么这个变换就是这个矩阵（参考二维情况下，二维平面中对向量的拉伸和旋转都可以通过一个二阶方阵来实现，高维空间中同理），而这个比例就是特征值。在<span class="math inline">\(n\)</span>维空间中，这样的特征向量最多有<span class="math inline">\(n\)</span>个，这个可以参考特征向量的求法，当转换成方程组之后，<span class="math inline">\(n\)</span>个方程组最多只能有<span class="math inline">\(n\)</span>组解。关于为什么要求矩阵的特征值和特征向量，这是根据优化问题的解得到的。假设降维后的矩阵为<span class="math inline">\(Y \in R^{m*k}\)</span>，转换矩阵为<span class="math inline">\(T\)</span>，那么<span class="math inline">\(Y\)</span>的协方差为</p><p><span class="math display">\[CovY=Y * Y^T * \frac{1}{m}\]</span></p><p><span class="math display">\[=(TY) * (TY)^T * \frac{1}{m}\]</span></p><p><span class="math display">\[=T * CovX * T^T\]</span></p><p>所以对于转换矩阵<span class="math inline">\(T\)</span>，我们需要通过计算后，使得<span class="math inline">\(CovY\)</span>为一个对角矩阵，并且矩阵中的值依次从大到小排列，因为根据优化的目标，我们需要使<span class="math inline">\(CovY\)</span>的对角线上的值最大，且除对角线以外的数都为0。我们知道，实对称矩阵的不同特征向量是正交的。所以将<span class="math inline">\(CovX\)</span>进行特征分解求出特征值和特征向量，然后取前<span class="math inline">\(k\)</span>组特征向量组成转换矩阵<span class="math inline">\(T\)</span>，就可以使得降维后的矩阵<span class="math inline">\(Y\)</span>的维度与维度之间的差异值最大。 关于代码和计算，matlab中有princomp和pca函数可以直接计算。 这里数据用的是鸢尾花数据集， 代码如下：</p><p></p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">load fixeddata; <br>[coeff,score,latent] = pca(newdata); <br>result=score(:,<span class="hljs-number">1</span>:<span class="hljs-number">2</span>); <br>x=result(:,<span class="hljs-number">1</span>); <br>y=result(:,<span class="hljs-number">2</span>); <br><span class="hljs-built_in">scatter</span>(x,y,<span class="hljs-string">'x'</span>); <br></code></pre></td></tr></tbody></table></figure><p></p><p>结果如图：</p><figure><img src="/img/dimensionality-reduction/2.png" alt=""><figcaption>result of PCA</figcaption></figure><p>综上，PCA是一种很常用的降维方法，也是一种无监督的降维方法。同时，从PCA的原理中可以看出，PCA对于线性相关的降维效果会比较好，但是对于非线性的数据，其降维效果可能就会差很多。</p>]]></content>
    
    
    <categories>
      
      <category>MACHINE LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PCA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Matlab搭建深度学习神经网络</title>
    <link href="/2020/01/21/DeepLearning/Deep-Leaning-Using-Matlab/"/>
    <url>/2020/01/21/DeepLearning/Deep-Leaning-Using-Matlab/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol type="1"><li><p>常见的matlab搭建神经网络的代码结构</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">options = trainingOptions(solverName, Name, Value);<br>layer = [layer1, layer2];<br>net = trainNetwork(TrainX, TrainY, options, layers);<br></code></pre></td></tr></tbody></table></figure><p>其中，trainingOptions的主要作用就是设置网络中的一些参数，主要包括以下参数：</p><table><thead><tr class="header"><th>参数名称</th><th>参数值</th><th>参数含义</th></tr></thead><tbody><tr class="odd"><td>solverName</td><td>'sgdm'|'rmsprop'|'adam'</td><td>优化方法</td></tr><tr class="even"><td>Plots</td><td>'none' | 'training-progress'</td><td>是否画优化曲线</td></tr><tr class="odd"><td>Verbose</td><td>1 | 0</td><td>是否显示优化信息，包括Loss，Epoch等信息</td></tr><tr class="even"><td>VerboseFrequency</td><td>int value</td><td>多长时间刷新一次信息，默认值是50</td></tr><tr class="odd"><td>MaxEpochs</td><td>int value</td><td>最大循环次数，训练数据最多重复多少次</td></tr><tr class="even"><td>MiniBatchSize</td><td>int value</td><td>最小的batch size，每次训练的最小数据量</td></tr><tr class="odd"><td>‘Shuffle'</td><td>’once‘ | 'never' | 'every-epoch'</td><td>每个epoch是否重新排序训练数据</td></tr><tr class="even"><td>‘ValidationData'</td><td>imageData，Data Store, Table，Cell array{X, Y}</td><td>用来验证网络的数据，一般用cell</td></tr><tr class="odd"><td>'ValidationFrequency'</td><td>int value</td><td>迭代多少次验证一次</td></tr><tr class="even"><td>’ValidationPatience'</td><td>int value</td><td>如果这次的验证loss比上一次大，这种情况出现的次数超过这个值，那么停止网络训练</td></tr><tr class="odd"><td>‘InitialLearnRate'</td><td>scalar</td><td>初始学习率</td></tr><tr class="even"><td>'LearnRateSchedule'</td><td>'none'|'piecewise'</td><td>调整学习率下降的方法，’piecewise‘方法会隔特定数目的epoch(LearnRateDropPeriod)就将LearnRate乘以一个factor(LearRateDropFactor)</td></tr><tr class="odd"><td>’LearnRateDropPeriod'</td><td>int value</td><td>隔特定数目的epoch调整一次LearnRate</td></tr><tr class="even"><td>‘LearnRateDropFactor’</td><td>scalar(0-1)</td><td>每次LearnRate调整时乘以的因子</td></tr><tr class="odd"><td>‘L2Regularization'</td><td>nonnegative scalar</td><td>用来减少过拟合，（需要继续学习）</td></tr><tr class="even"><td>’Momentum'</td><td>scalar(0-1)</td><td>动量，sgdm中前一次迭代中的参数在下一次迭代中所占的比例</td></tr><tr class="odd"><td>‘GradientDecayFactor'</td><td>scalar(0-1)</td><td>adam方法中梯度值降低的平均值</td></tr><tr class="even"><td>’SquaredGradientDecayFactor‘</td><td>nonnegative scalar less than 1</td><td>梯度平方降低的平均值（Adam， RMSProp）</td></tr><tr class="odd"><td>’Epsilon‘</td><td>int value</td><td>分母的偏置值(Adam, RMSProp)</td></tr><tr class="even"><td>'ResetInputNormalization'</td><td>true | false</td><td>每次训练都将输入值标准化</td></tr><tr class="odd"><td>’GradientThreshold‘</td><td>int value</td><td>梯度的阈值</td></tr><tr class="even"><td>’GradientThresholdMethod‘</td><td>’l2norm‘|'global-l2norm'|'absolute-value'</td><td>梯度阈值的计算方法</td></tr><tr class="odd"><td>’SequenceLength‘</td><td>'longest'|'shortest'|int value</td><td>输入的序列长度</td></tr><tr class="even"><td>’SequencePaddingDirection‘</td><td>’right'|'left'</td><td>如果序列需要截取，截取的方向</td></tr><tr class="odd"><td>‘SequencePaddingValue’</td><td>int value</td><td>填充到序列中的值，用来补充数据长度</td></tr><tr class="even"><td>‘ExecutionEnvironment’</td><td>‘auto’|'cpu'|'gpu'|'multi-gpu'|'parallel'</td><td>选择硬件</td></tr><tr class="odd"><td>‘WorkLoad’</td><td>scalar(0-1)|int|vector</td><td>GPU或CPU的负载，用到的核心数，以及并行计算时的负载</td></tr><tr class="even"><td>‘DispatchInBackground’</td><td>false | true</td><td>后台拆分数据并分配核心同时读取</td></tr><tr class="odd"><td>‘CheckpointPath’</td><td>character</td><td>存放网络训练中间值的路径</td></tr><tr class="even"><td>‘OutputFunc’</td><td>function handle</td><td>网络训练时，trainNetwork函数会在刚开始训练时，每次迭代结束时，训练结束时调用这个函数</td></tr></tbody></table><p>trainingOptions函数主要用来设置网络训练过程中的参数，需要熟悉其中的参数的作用</p><p>layers主要表示网络的结构，层与层之间的连接等，其中主要包括各种网络层，目前常用的有如下几类：</p><table><thead><tr class="header"><th>网络层</th><th>参数</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>allLayer</td><td>Name</td><td>网络层的名称</td></tr><tr class="even"><td></td><td>NumInputs</td><td>输入的个数</td></tr><tr class="odd"><td></td><td>InputNames</td><td>输入数据的名称，cell</td></tr><tr class="even"><td></td><td>NumOutputs</td><td>输出的个数</td></tr><tr class="odd"><td></td><td>OutputNames</td><td>输出数据的名称，cell</td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td>sequenceLayer</td><td>InputSize</td><td>输入序列的大小，如果是图像的话，那么就是一个三维或四维矩阵</td></tr><tr class="even"><td></td><td>Normalization</td><td>数据归一化的方法选择</td></tr><tr class="odd"><td></td><td>NormalizationDimension</td><td>归一化的维度，按照通道，按照元素或者全部统一</td></tr><tr class="even"><td></td><td>Mean</td><td>设置数据的均值配合zscore和zerocenter等归一化方法使用</td></tr><tr class="odd"><td></td><td>StandardDeviation</td><td>标准差，配合对应的归一化方法使用</td></tr><tr class="even"><td></td><td>Min</td><td>归一化后的最小值</td></tr><tr class="odd"><td></td><td>Max</td><td>归一化后的最大值</td></tr><tr class="even"><td></td><td></td><td></td></tr><tr class="odd"><td>fullyConnectedLayer</td><td>OutputSize</td><td>输出层大小</td></tr><tr class="even"><td></td><td>InputSize</td><td>输入层大小</td></tr><tr class="odd"><td></td><td></td><td></td></tr></tbody></table></li></ol>]]></content>
    
    
    <categories>
      
      <category>DEEP LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kalman滤波</title>
    <link href="/2019/11/03/MachineLearning/Kalman/"/>
    <url>/2019/11/03/MachineLearning/Kalman/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文简单介绍了卡尔曼滤波(Kalman Filter)的基本原理以及我对卡尔曼滤波的一些理解。</p><h5 id="首先谈一下我的一点点理解">首先谈一下我的一点点理解</h5><p>卡尔曼滤波是目前应用很广泛的一种滤波方法，最早由Kalman老先生在1960年提出，网上可以找到原文。这种方法最开始用在航天领域，作为轨道矫正的一种方法，有很好的效果。</p><p>卡尔曼滤波的方法的核心思想，就是用另一个测量空间的观测值去纠正当前空间对被测量的量的估计。简单来说，就是用一种方法去测量一个量。同时建立一个模型去估计这个测量的量，最后，按权重的方式求这两种方式的和，就是滤波之后的量的值。而这个权重的大小，就是卡尔曼系数。</p><h5 id="公式推导">公式推导</h5><p>首先，我们假设要测量的量为<span class="math inline">\(x\)</span>, 这个量有一个模型去描述其随时间的变化，例如计算每天的温度变化，可以大致根据之前几天的温度变化规律得到一个计算矩阵，这里也有一个计算模型去计算这个变量<span class="math inline">\(x\)</span></p><p><span class="math display">\[x_t=Fx_{t-1} + w_t\]</span></p><p><span class="math display">\[w_{t} - N(0,Q)\]</span></p><p>其中<span class="math inline">\(F\)</span>为转换矩阵，<span class="math inline">\(w_{t-1}\)</span>表示<span class="math inline">\(t-1\)</span>时刻的噪声，且该噪声服从高斯分布。在其他的卡尔曼滤波公式推导中，会有一个额外的控制量，这里不考虑这个量。</p><p>对于测量矩阵，也有一个公式去转换。例如测量温度可以用温度传感器来测量，但是温度传感器的测量是因为温度改变了电阻的阻值，所以根据电压电流以及电阻随温度的变化曲线而计算出来的。在卡尔曼模型中，这一公式可以表示为如下等式</p><p><span class="math display">\[z_t=Hx_t+v_t\]</span></p><p><span class="math display">\[v_t - N(0,R)\]</span></p><p>其中，<span class="math inline">\(z_t\)</span>是通过测量的量，对应到上述的例子中，就是温度传感器的电阻阻值，<span class="math inline">\(x_t\)</span>就是温度。<span class="math inline">\(H\)</span>是测量矩阵，用来将测量的量转换成要估计的量。<span class="math inline">\(v_t\)</span>是测量过程中存在的误差。同样的，<span class="math inline">\(v_t\)</span>也是服从高斯分布的白噪声。</p><p>然后就是卡尔曼滤波的核心思想了，有了这两种方法得到的<span class="math inline">\(x_t\)</span>，那么怎么得到一个更准确的估计值。所以需要将两种方法得到的估计值进行算一下加权平均，就得到了最优的估计值。所以卡尔曼滤波的方法如下：</p><ol type="1"><li><p>首先根据模型计算当前时刻的估计值 <span class="math display">\[x_t'=Fx_{t-1} + w_t\]</span></p></li><li><p>然后根据测量矩阵计算当前的测量值的估计值</p></li></ol><p><span class="math display">\[z_t'=Hx_t'+v_t\]</span></p><ol start="3" type="1"><li>然后计算测量值和测量估计值之间的差，并以此作为对最终估计值的调整。从这里可以看出，如果<span class="math inline">\(x_t'\)</span>估计的很准，就是说此时<span class="math inline">\(z_t\)</span>的值和<span class="math inline">\(z_t'\)</span>的值相差很小，那么<span class="math inline">\(z_t\)</span>对于<span class="math inline">\(x_t\)</span>的修正也就越少。但是如果估计值和测量值相差很大，那么<span class="math inline">\(z_t\)</span>对<span class="math inline">\(x_t\)</span>的修正也就越大。其中，<span class="math inline">\(K_t\)</span>是卡尔曼增益，表示滤波器对测量值的信任程度。</li></ol><p><span class="math display">\[x_t=x_t'+K_t*(z_t-z_t')\]</span></p><p>那么如何估计卡尔曼增益，可以用贝叶斯估计的方法推导，也可以用最小二乘法的方式推导，这里用最小二乘法的方式推导</p><p>我们假设真实值是<span class="math inline">\(X_t\)</span>，那么卡尔曼滤波计算得到的估计值和真实值之间的协方差</p><p><span class="math display">\[P(x_t|X_t)= E[(X_t-x_t)(X_t-x_t)^T]\]</span></p><p>卡尔曼滤波的估计值和模型的估计值之间的协方差，用来评估两种估计的差别</p><p><span class="math display">\[P(x|x')=E[(x_t-x_t')(x_t-x_t')^T]\]</span></p><p>根据卡尔曼的估计公式以及测量公式，可以得到</p><p><span class="math display">\[P(x_t|X_t)=E [(X_t - x_t' - K_t * ( z_t - z_t')) ( X_t - x_t' - K_t * ( z_t - z_t' ))^T]\]</span></p><p><span class="math display">\[=E[((I-K_tH)(X_t-x_t')-K_tv_t)((I-K_tH)(X_t-x_t')-K_tv_t)^T]\]</span></p><p>把上述等式展开，可以得到 <span class="math display">\[P(x_t|X_t)=(I-K_tH)P(x_t|x_t')(I-K_tH)+K_tE[v_tv_t^T]K_t^T\]</span></p><p><span class="math display">\[=P(x_t|x_t')-K_tHP(x_t|x_t')-P(x_t|x_t')H^TK_t^T+K_t(HP(x_t|x_t')H^T+R)K_t^T\]</span></p><p>所以，如果我们要估计的更准确，那么就要<span class="math inline">\(P(x_t|X_t)\)</span>更小，就是说真实值和卡尔曼滤波的估计值之间的协方差最小。不考虑估计值之间的相关，那么协方差矩阵的对角线元素就表示了卡尔曼估计值和真实值之间的方差。接下来就是求方差最小的情况下对应的卡尔曼增益<span class="math inline">\(K_t\)</span>。可以用矩阵的迹的方法求解 <span class="math display">\[tr(P(x_t|X_t)) = tr(P(x_t|x_t'))-2tr(K_tHP(x_t|x_t'))+tr(K_t(HP(x_t|x_t')H^T+R)K_t^T)\]</span></p><p>可以看出，<span class="math inline">\(tr(P(x_t|X_t))\)</span>是<span class="math inline">\(K_t\)</span>的二次函数，所以根据二次函数求极值的方法，对tr(P(x_t|X_t))求导，得到</p><p><span class="math display">\[\frac{d(tr(P(x_t|X_t)))}{d(K_t)}=-2(HP(x_t|x_t'))^T+2K_t(HP(x_t|x_t')H^T+R)\]</span></p><p>令<span class="math inline">\(\frac{d(tr(P(x_t|X_t)))}{d(K_t)}=0\)</span>，所以有</p><p><span class="math display">\[K_t=P(x_t|x_t')H^T(HP(x_t|x_t')H^T+R)^{-1}\]</span></p><p>把<span class="math inline">\(K_t\)</span>的结果带入到<span class="math inline">\(P(x_t|X_t)\)</span>的表达式中，有</p><p><span class="math display">\[P(x_t|X_t)=P(x_t|x_t')-K_tHP(x_t|x_t')-P(x_t|x_t')H^TK_t^T+K_t(HP(x_t|x_t')H^T+R)K_t^T\]</span></p><p><span class="math display">\[=P(x_t|x_t')-K_tHP(x_t|x_t')-\frac{HP(x_t|x_t')^TP(x_t|x_t')H^T}{HP(x_t|x_t')H^T+R}+\frac{HP(x_t|x_t')^TP(x_t|x_t')H^T}{HP(x_t|x_t')H^T+R}\]</span></p><p><span class="math display">\[=P(x_t|x_t')-K_tHP(x_t|x_t')=(I-K_tH)P(x_t|x_t')\]</span></p><p>所以根据上述的推导计算，可以得到卡尔曼滤波的计算过程：</p><ol type="1"><li>首先，根据已知的模型，以及上一时刻的卡尔曼估计值，计算当前时刻的模型预测值</li></ol><p><span class="math display">\[x_t'=Fx_{t-1}\]</span></p><ol start="2" type="1"><li>根据当前的模型预测值，计算对应的协方差</li></ol><p><span class="math display">\[P(x_t|x_t')=FP(x_t|X_t)F^T\]</span></p><ol start="3" type="1"><li>根据当前的协方差和测量空间的转换矩阵，计算当前时刻的卡尔曼增益</li></ol><p><span class="math display">\[K_t=P(x_t|x_t')H^T(HP(x_t|x_t')H^T+R)^{-1}\]</span></p><ol start="4" type="1"><li>根据卡尔曼增益和测量值，计算当前时刻的卡尔曼估计值</li></ol><p><span class="math display">\[x_t=x_t'+K_t(z_t-Hx_t')\]</span></p><ol start="5" type="1"><li>计算了当前时刻的卡尔曼估计值之后，还需要计算当前的估计值和真实值的协方差矩阵，方便下一次计算</li></ol><p><span class="math display">\[P(x_t|X_t)=(I-HK_t)P(x_t|x_t')\]</span></p><p>以上就是卡尔曼滤波的基本过程，以及一些简单的推导。总体上说理解卡尔曼滤波应该算一种最优估计的算法。也是应用很广泛的，然后卡尔曼滤波的推导方法也有很多，除了最小二乘法，也可以从贝叶斯估计的角度推导。两者是类似的。</p><h5 id="code">Code</h5>]]></content>
    
    
    <categories>
      
      <category>MACHINE LEARNING</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kalman</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
